<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    OpenCL入门 |
    
    Mushroom&#39;s blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/images/M.svg">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-OpenCl" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  OpenCL入门
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/08/OpenCl/" class="article-date">
  <time datetime="2022-09-07T17:01:37.000Z" itemprop="datePublished">2022-09-08</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>只是入门，用来讲解一些基础的概念的。</p>
<p>应该没啥特别深的内容。</p>
<span id="more"></span>

<p>首先我们需要明白的是，OpenCL程序是分成两部分的：一部分是在设备上执行的（对于我们，是GPU/FPGA），另一部分是在主机上运行的（对于我们，是CPU）。在设备上执行的程序或许是你比较关注的。它是OpenCL产生神奇力量的地方。为了能在设备上执行代码，程序员需要写一个特殊的函数（kernel函数）。这个函数需要使用OpenCL语言编写。OpenCL语言采用了C语言的一部分加上一些约束、关键字和数据类型。在主机上运行的程序提供了API，所以i可以管理你在设备上运行的程序。主机程序可以用C或者C++编写，它控制OpenCL的环境（上下文，指令队列…）。</p>
<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><p>一些概念：</p>
<ul>
<li><strong>Kernel：</strong>你可以把它想像成一个可以在设备上执行的函数。当然也会有其他可以在设备上执行的函数，但是他们之间是有一些区别的。Kernel是设备程序执行的入口点。换言之，Kernel是唯一可以从主机上调用执行的函数。</li>
</ul>
<p>现在的问题是：我们如何来编写一个Kernel？在Kernel中如何表达并行性？它的执行模型是怎样的？解决这些问题，我们需要引入下面的概念：</p>
<ul>
<li><p><strong>SIMT</strong>：单指令多线程（SINGLE INSTRUCTION MULTI THREAD）的简写。就像这名字一样，相同的代码在不同线程中并行执行，每个线程使用不同的数据来执行同一段代码。</p>
</li>
<li><p> <strong>Work-item（工作项）</strong>：Work-item与CUDA Threads是一样的，是最小的执行单元。每次一个Kernel开始执行，很多（程序员定义数量）的Work-item就开始运行，每个都执行同样的代码。每个work-item有一个ID，这个ID在kernel中是可以访问的，每个运行在work-item上的kernel通过这个ID来找出work-item需要处理的数据。</p>
</li>
<li><p><strong>Work-group（工作组）</strong>：work-group的存在是为了允许work-item之间的通信和协作。它反映出work-item的组织形式（work-group是以N维网格形式组织的，N=1，2或3）。</p>
<blockquote>
<p>Work-group等价于CUDA thread blocks。像work-items一样，work-groups也有一个kernel可以读取的唯一的ID。</p>
</blockquote>
</li>
<li><p><strong>ND-Range</strong>:ND-Range是下一个组织级别，定义了work-group的组织形式（ND-Rang以N维网格形式组织的，N=1，2或3）；</p>
</li>
</ul>
<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>一些例子：</p>
<p>我们写一个小的kernel将两个向量相加。这个kernel需要四个参数：两个要相加的向量，一个存储结果的向量，和向量个数。如果你写一个程序在cpu上解决这个问题，将会是下面这个样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vector_add_cpu</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">float</span>* src_b,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">float</span>*  res,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">      res[i] = src_a[i] + src_b[i];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>在GPU上，逻辑就会有一些不同。我们使每个线程计算一个元素的方法来代替cpu程序中的循环计算。每个线程的index与要计算的向量的index相同。我们来看一下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__kernel <span class="keyword">void</span> <span class="title">vector_add_gpu</span> <span class="params">(__global <span class="keyword">const</span> <span class="keyword">float</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                     __global <span class="keyword">const</span> <span class="keyword">float</span>* src_b,</span></span></span><br><span class="line"><span class="params"><span class="function">                     __global <span class="keyword">float</span>* res,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="comment">/* get_global_id(0) 返回正在执行的这个线程的ID。</span></span><br><span class="line"><span class="comment">   许多线程会在同一时间开始执行同一个kernel，</span></span><br><span class="line"><span class="comment">   每个线程都会收到一个不同的ID，所以必然会执行一个不同的计算。*/</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> idx = <span class="built_in">get_global_id</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 每个work-item都会检查自己的id是否在向量数组的区间内。</span></span><br><span class="line"><span class="comment">   如果在，work-item就会执行相应的计算。*/</span></span><br><span class="line">   <span class="keyword">if</span> (idx &lt; num)</span><br><span class="line">      res[idx] = src_a[idx] + src_b[idx];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>有一些需要注意的地方：</p>
<ol>
<li><p>Kernel关键字定义了一个函数是kernel函数。Kernel函数必须返回void。</p>
</li>
<li><p>Global关键字位于参数前面。它定义了参数内存的存放位置。</p>
</li>
</ol>
<p>另外，所有kernel都必须写在“.cl”文件中，“.cl”文件必须只包含OpenCL代码。</p>
<h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><p><strong>Plantform（平台）</strong>：主机加上OpenCL框架管理下的若干设备构成了这个平台，通过这个平台，应用程序可以与设备共享资源并在设备上执行kernel。平台通过cl_plantform来展现，可以使用下面的代码来初始化平台：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the error code</span></span><br><span class="line"></span><br><span class="line"><span class="function">cl_int <span class="title">oclGetPlatformID</span> <span class="params">(cl_platform_id *platforms)</span> <span class="comment">// Pointer to the platform object</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Device（设备）</strong>：通过cl_device来表现，使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the error code</span></span><br><span class="line"></span><br><span class="line"><span class="function">cl_int <span class="title">clGetDeviceIDs</span> <span class="params">(cl_platform_id platform,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cl_device_type device_type, <span class="comment">// Bitfield identifying the type. For the GPU we use CL_DEVICE_TYPE_GPU</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cl_uint num_entries, <span class="comment">// Number of devices, typically 1</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cl_device_id *devices, <span class="comment">// Pointer to the device object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cl_uint *num_devices)</span> <span class="comment">// Puts here the number of devices matching the device_type</span></span></span><br></pre></td></tr></table></figure>

<p>关于设备类型(device_type):<br>CL_DEVICE_TYPE_ALL<br>和平台相关的所有设备</p>
<p>CL_DEVICE_TYPE_DEFAULT<br>和平台默认类型相关的设备</p>
<p>CL_DEVICE_TYPE_CPU<br>主机处理器</p>
<p>CL_DEVICE_TYPE_GPU<br>包含GPU的设备</p>
<p>CL_DEVICE_TYPE_ACCELERATOR<br>外部设备用来加速运算</p>
<h2 id="程序和kernel"><a href="#程序和kernel" class="headerlink" title="程序和kernel"></a>程序和kernel</h2><p>到现在为止，你可能会问自己一些问题，比如：我们怎么调用kernel？编译器怎么知道如何将代码放到设备上？我们怎么编译kernel？</p>
<p>下面是我们在对比OpenCL程序和OpenCL kernel时的一些容易混乱的概念：</p>
<p><strong>Kernel：</strong>你应该已经知道了，像在上文中描述的一样，kernel本质上是一个我们可以从主机上调用的，运行在设备上的函数。你或许不知道kernel是在运行的时候编译的！更一般的讲，所有运行在设备上的代码，包括kernel和kernel调用的其他的函数，都是在运行的时候编译的。这涉及到下一个概念，Program。</p>
<p><strong>Program：</strong>OpenCL Program由kernel函数、其他函数和声明组成。它通过cl_program表示。当创建一个program时，你必须指定它是由哪些文件组成的，然后编译它。</p>
<p>你需要用到下面的函数来建立一个Program：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the OpenCL program</span></span><br><span class="line"></span><br><span class="line"><span class="function">cl_program <span class="title">clCreateProgramWithSource</span> <span class="params">(cl_context context,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    cl_uint count, <span class="comment">// number of files</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> **strings, <span class="comment">// array of strings, each one is a file</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">size_t</span> *lengths, <span class="comment">// array specifying the file lengths</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    cl_int *errcode_ret)</span> <span class="comment">// error code to be returned</span></span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mushroom323.github.io/2022/09/08/OpenCl/" data-id="cl7t3extr000m1otb1w9c43gm" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E5%A4%96/" rel="tag">课外</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  
  <a href="/2022/09/03/Decision_Tree/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">决策树模型</div>
  </a>
  
</nav>

  

  
  
<div class="vcomments" id="vcomments"></div>

<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  new Valine({
    el: '#vcomments',
    appId: 'ufPR3EsabCPKRDngccwM3C57-gzGzoHsz',
    appKey: 'h1P7KQ81rD4E6n9G8GRYpenL',
    notify: 'false',
    verify: 'true',
    avatar: 'mp',
    pageSize: '10',
    placeholder: '发表神谕'
  })
</script>

  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Mushroom&#39;s blog &copy; 2022</li>
      
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/M.svg" alt="Mushroom&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/links">Links</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>