[{"title":"欢迎来到新废物主义街区","url":"/2021/11/25/encry/","content":"\r\n  0a89eacc09ebfc339e31b0be2517c76e29f2c828a05be492ef2a520146f938daa6e42da3f0bed97bd5ec56413d1b056bd5f7be2991015d203e81e618b3d46b8f64905cdb2287999d009f14e85f4427a7c9a681f1369f25b84c3b7c5f6c6fe34dc24c3cbfb3344600003fc6c067867f0eb79d92bf3969f7715dee6826ef9ed0bfcc1cf63d8b33ab0281a08b3727815c90\r\n  \r\n    \r\n      \r\n      \r\n        密码是新废物主义街区门牌号\r\n      \r\n    \r\n  \r\n\r\n","tags":["杂谈"]},{"title":"计网介质访问控制子层","url":"/2022/04/25/jiwang_4/","content":"这章我怎么感觉两周就讲完了。\n内容有这么少吗，我咋啥都没听懂。\nHIGH LIGHTSppt第一页划了重点。\n\nChannel allocation algorithms。信道分配算法。\nContention（竞争算法）： ALOHA,S-ALOHA,CSMA,CSMA/CD\nCollision-Free Protocols（无竞争协议）：Token （书上不止这个但是只有这个要考。其他俩只做了解\n\n\nLAN。局域网\nIEEE802.3, HIGH-SPEED LANS (802.3u)\nGigabit Ethernet(802.3z)\nIEEE802.11(WLAN)  \nLLC(802.2)\n\n\nBRIDGE\nREPEATER,HUB, BRIDGE,SWITCH,ROUTER （中继器、集线器、桥梁、交换机、路由器\nVLAN。虚拟局域网。\n\n4.1 信道分配问题分两种，静态划分和动态划分\n4.1.1 静态划分信道M/M/1 System\n懒得打表达式了直接放图。\n\n\n在时间T内到达的帧数K满足泊松分布，如图中左式。\n:表示到达的平均速率，单位frams/sec\n：表示帧长，单位bits/frame\nC:数据发送速率，信道容量（bits/sec），服务速率即为 μC frames/sec\n标准排队理论的结论：发送一帧的平均时延 \n没说怎么证\n\n\n\n将单个信道分成N个独立的子信道，每个子信道的容量为C/N bps。现在，每个子信道的平均到达率变成N。重新计算T，我们得到：如果所有帧都能很神奇地排在一个大的中心队列，那么划分信道后单个信道的平均延迟比不分的情况差N倍。\n也就是信道越多平均延迟越大。\n4.2.2 动态划分信道\nControlled multiple access 。 受控多路访问\n\n竞争： poolling\n不竞争： token\n\n\nRandom multiple access 。 随机多路访问\n\nALOHA\n CSMA, CSMA/CD, CSMA/CA\n\n\n动态信道划分的五个关键假设：\n\n流量独立(independent traffic)。该模型是由N个独立的站(比如计算机、电话)组成的，每个站都有一个程序或者用户产生要传输的帧。在长度为Δt的间隔内，期望产生的帧数是Δt，这里为常数(新帧的到达率)。\n单信道(Single Channel)。所有的通信都用这一个信道\n冲突可观察(observable Collision)。如果两帧同时传输，则它们在时间上就重叠，由此产生的信号是混乱的，这种情况称为冲突(collision)。所有的站都能够检测到冲突事件的发生。冲突的帧必须在以后再次被发送。除了因冲突而产生错误外，不会再有其他的错误\n时间连续或分槽(Continuous or slotted time)。时间可以假设是连续的，即在任何时刻都可以开始传输帧。另一种选择是把时间分槽或者分成离散的间隔(称为时间槽)。帧的传输只能从某个时间槽的起始点开始\n载波侦听或不听(Carrier Sense or no carrier sense)。有了载波侦听的假设，一个站在试图用信道之前就能知道该信道当前是否正被使用。如果没有载波侦听，站就无法在使用信道之前侦听信道，它们只能盲目地传输，以后再判断这次传输是否成功\n\n\n\n4.2 多路访问协议4.2.1 ALOHA\nALOHA的基本思想\n\nALOHA系统的基本思想非常简单：当用户有数据需要发送时就传输。当然，这样做可能会产生冲突，冲突的帧将被损坏。发送方需要某种途径来发现是否发生了冲突。在ALOHA系统中，每个站在给中央计算机发送帧之后，该计算机把该帧重新广播给所有站。\n\n如果帧被损坏了，则发送方要等待一段随机时间，然后再次发送该帧。\n\n 我们使所有的帧具有同样的长度， 因为对于ALOHA系统，采用统一长度的帧比长度可变的帧更能达到最大的吞吐量。\n\n\n\n竞争(contention)\n\n如果系统中多个用户共享同一个信道的方法会导致冲突，则这样的系统称为竞争(contention) 系统。\n\n\n\nPURE ALOHA一眼纯真。\n纯ALOHA里，帧完全随机传输。\n冲突危险期是 2T，因为他前面的那段时间T也不能有，否则部分冲突。看图：\n\n纯ALOHA效率分析：发送成功概率是 \n\nG = 0.5是S最大为18.4%\nSLOT ALOHA分槽。\n\n基本思想：\n将时间分成离散的间隔，每个间隔对应一帧，每个站点只能在时隙i开始时才允许发送（冲突只发生在时隙开始的时候），所以每个用户必须知道槽边界(同步)。其他的跟纯ALOHA一样冲突危险期是T\n\n\n效率分析：\n\n每帧的传输次数期望E：所以，E随G呈指数增长的。结果是信道负载的微小增长也会极大地降低信道的性能。\n\n\n\n4.2.2 载波侦听多路访问协议单通道的CSMA/CD本质上是一种半双工系统\n\n站点在发送之前监听载波。\n分类\n1-persistent CSMA\nNonpersistent CSMA\nP-persistent CSMA (slotted channel)\n\n\n\nCSMA Collision Reasons一点很关键但放在这里莫名其妙的知识。\nppt神秘莫测。\nCAMA/CD有三个状态：竞争，传输，或者空闲。\n给个1-p协议的例子方便理解，AB都是检测到空闲就开始发送：是从信道最左边到信道最右边需要的传输时间。这里考虑的是最极限的情况，A的帧传输到B门口，B才开始发帧，这时离A发送过了。然后碰撞信息从B门口回到A门口有又需要。所以说竞争时间 = ，如果内发送方都没有检测到碰撞信息，那就说明真没碰撞，发送成功了。\n1-persistent CSMA（1-坚持载波检测多路访问当一个站有数据要发送时，它首先侦听信道，确定当时是否有其他站正在传输数据；如果信道空闲，它就发送数据。否则，如果信道忙，该站等待直至信道变成空闲；然后，站发送一帧。如果发生冲突，该站等待段随机的时间，然后再从头开始上述过程。这样的协议之所以称为1-坚持，是因为当站发现信道空闲时，它传输数据的概率为1。\n低延迟，低吞吐率\n\n低延迟是因为信道空闲就开始发送，低吞吐率（平均时间内成功发送的帧数）是因为经常冲突，经常重发。\n\nNonpersistent CSMA（非坚持站在发送数据之前要先侦听信道。如果没有其他站在发送数据，则该站自己开始发送数据。然而，如果信道当前正在使用中，则该站并不持续对信道进行监听，以便传输结朿后立即抓住机会发送数据。相反，它会等待一段随机时间，然后重复上述算法。因此，该算法将会导致更好的信道利用率，但是比起1-坚持CSMA，也带来了更大的延迟\n高延迟，高负载时高吞吐率\n\n高延迟是因为帧准备好了还得等一段随机事件，高负载高吞吐是因为随机事件后两个帧很难碰到一起，发送成功率高。\n\nP-persistent CSMA （P坚持它适用于分时间槽的信道，其工作方式如下所述。当一个站准备好要发送的数据时，它就侦听信道。如果信道是空闲的， 则它按照概率p发送数据；而以概率q=1-p，将此次发送推迟到下一个时间槽。如果下个时间槽信道也是空闲的，则它还是以概率p发送数据，或者以概率q再次推迟发送。\n看个比较图\n4.2.3 无冲突协议Token Ring 令牌环就是个令牌，谁拿到谁发数据。要找个站点记得把令牌取下来，不然就一直转。\n通过传递一个称为令牌(token)的短消息，该令牌同样也是以预定义的顺序从一个站传到下一个站。令牌代表了发送权限。如果站有个等待传输的帧队列，当它接收到令牌就可以发送帧，然后再把令牌传递到下一站。如果它没有排队的帧要传，则它只是简单地把令牌传递下去。\n帧也按令牌方向传输。这样，它们将绕着环循环，到达任何一个目标站。然而，为了阻止帧陷入无限循环(像令牌一样)，一些站必须将它们从环上取下来。这个站或许是最初发送帧的原始站，在帧经历了一个完整的环游后将它取下来，或者是帧的指定接收站。\n发送帧后，每个站必须等待所有N个站(包括其自身)把令牌发给各自的邻居，以及其他N-1个站发送完一帧(如果它们有帧需要发送)\n并不需要一个物理环来实现令牌传递\n\n4.2.4 Limited-Contention Protocols 有限竞争协议在负载较轻的情况下，竞争方法(即纯ALOHA或者分槽ALOHA)更为理想，因为它的延迟较短(冲突很少发生)。随着负载的增加，竞争方法变得越来越缺乏吸引力，因为信道仲裁所需要的开销变得越来越大。而对于无冲突协议，则结论刚好相反。在低负载情况下，它们有相对高的延迟，但是随着负载的增加，信道的效率反而得到提高(因为开销是固定的)。\n\n低负载竞争好使，高负载无竞争好使。\n\n有限竞争协议(limited-contention protocol)只要减少参与竟争的站数量，则站获得信道的概率就会增加。有限竟争协议正是这样做的。它们首先将所有的站划分成组(这些组不必是两两不相交的)。有0号组的成员才允许竞争0号时间槽。如果该组中的一个成员竞争成功了，则它获得信道，可以传送它的帧。如果该时间槽是空闲的，或者发生了冲突，则1号组的成员竞争1号时间槽，以此类推。\n\n组内用的是无竞争，比如token\n\n当负载很低时，每个时间槽中的站点数量就多一些；当负载很高时，每个时间槽中的站点数量就少ー些，甚至只有一个站。\n\n负载越高越往无竞争靠\n\n4.2.5 无线局域网协议\n传播范围假设：\n简化的假设：即每个无线电发射器有某个固定的传播范围，用一个圆形覆盖区域表示\n\n\n\n\n\n隐藏终端问题(hidden station problem)\n因为冲突将导致带宽的浪费。由于竞争者离得太远而导致站无法检测到潜在的竞争者，这个问题称为隐藏终端问题(hidden station problem)\n图（a）\n\n\n\n\n暴露终端问题(exposed station problem)\nC所听到的传输只会搞坏B和C之间区域中的接收，但是，两个接收方都不在这个危险区域\n图（b）。\n\n\n\n\n\n俩问题综合一下就是： CSMA没法用了。\n那咋办呢，整点新活呗。\nMACA 冲突避免多路访问反正检测不了冲突，那就干脆避免了拉倒。\n好活。\nMACA的基本思想是发送方刺激接收方输出一个短帧，以便其附近的站能检测到该次传输，从而避免在接下去进行的(较大)数据帧传输中也发送数据。这项技术被用来替代载波侦听。\nA首先给B发送个RTS(Request To Send)帧，如图4-12(a)所示。这个短帧(30字节)包含了随后将要发送的数据帧的长度；然后，B用一个CTS(Clear to Send)作为应答，如图4-12(b)所示。此CTS帧也包含了数据长度(从RTS帧中复制过来)。A在收到了CTS帧之后便开始传输。\n如果一个站听到了RTS帧，那么它一定离A很近，它必须保持沉默，至少等待足够长的时间以便在无冲突情况下CTS被返回给A。如果一个站听到了CTS，则它一定离B很近，在接下来的数据传送过程中它必须一直保持沉默，只要检査CTS帧，该站就可以知道数据帧的长度(即数据传输要持续多久)。\n在图4-12中，C落在A的范围内，但不在B的范围内。因此，它听到了A发出的RTS，但是没有听到B发出的CTS。只要它没有干扰CTS，那么在数据帧传送过程中，它可以自由地发送任何信息。相反，D落在B的范围内，但不在A的范围内。它听不到RTS帧，但是听到了CTS帧。只要听到了CTS帧，这意味着它与个将要接收数据帧的站离得很近；所以，它就延缓发送任何信息直到那个帧如期传送完毕。站E听到了这两条控制消息，与D一样在数据帧完成之前它必须保持安静。\n\n总结一下就是听到RTS的沉默一段时间，听到CTS或者都听到的一直沉默。\n\n\n4.3 以太网不知道咋学，不知道咋考。\nEthernet Cabling 以太网电缆以太网电缆有三种：\n\n10Base5 粗同轴电缆\n10Base2 细同轴电缆\n10Base-T 双绞线\n\n\n10Base5: Thick Ethernet有些懒得翻译。直接放ppt原文。\n\ncable 电缆\n\nΦ10,  Coax, 500m\nConnections to it are generally made using vampire taps, in which a pin is very carefully forced halfway into the coaxial cable’s core \n\n\nTransceiver cable 收发器电缆\n\n将收发器连接到计算机的接口板\n五十米长以上\n包含五对互相屏蔽的双绞线\n两对用于输入输出\n两对用于控制信息的输入输出\n第五对不经常使用，它允许计算机为收发电子设备供电\n\n\n\n\nInterface board 接口板\n\n传输和接收帧，将数据组装成适当的帧格式，处理校验和\n为传入的帧管理一个缓冲池，一个要传输的缓冲队列，直接与主机进行内存传输\n\n\nTransceiver  收发器\n\n处理载波检测和碰撞检测\n对于碰撞，在电缆上放置一个特殊的无效信号，以确保所有其他收发器也意识到已经发生了碰撞\n\n\n\n10Base2: Thin Ethernet三行结束。排场比粗缆逊多了\n\nCable: Φ5,  Coax, 185m\nBNC T-junction connector\n收发器电子器件在控制板上\n\n10BaseT排场略大于细缆。\nppt蛮多中文，直接放了\n\n\n使用集线器（Hub）来扩大局域网\n\n以太网拓扑结构\n\n线性\nSpine（脊椎形？\n树形\n分段式\n\n\n\nManchester Encoding 曼彻斯特编码非差分：中间变一下用来对时。起始是高就是1，低就是0差分： 中间变一下对时，起始没跳变就是1，否则是0\n4.3.2 以太网的MAC子层协议MAC格式\n\n\n目标地址\n\n如果传输出去的目标地址第一位是0，则表示这是一个普通地址；如果是1，则表示这是一个组地址。组地址允许多个站同时监听一个地址。当某个帧被发送到一个组地址， 该组中的所有站都要接收它。往一组地址的发送行为称为组播(multicasting)。**由全1组成的特殊地址保留用作广播(broadcasting)**。如果一个帧的目标地址字段为全1，则它被网络上的所有站接收。\n\n\nMAC地址\n\n站的源地址有一个有趣的特点，那就是它们具有全球唯一性。\n地址字段的前3个字节用作该站所在的组织唯一标识符(OUI, Organizationally Unique Identifier)。该字段的值由IEEE分配，指明了网络设备制造商。\n地址字段的最后3个字节由制造商负责分配，并在设备出厂之前把完整的地址用程序编入NIC（网卡\n\n\n数据字段和长度范围\n\n接下来是数据(Data)字段，（Data）最多可包含1500个字节。总帧长度最多1518字节。\n以太网要求有效帧必须至少64字节长，从目标地址算起直到校验和，包括这两个字段本身在内。如果帧的数据部分少于46个字节，则使用填充(Pad)字段来填充该帧，使其达到最小长度要求\n也就是说不包含pad的时候，数据部分最少46个字节要求最少是因为竞争时间()的问题。要是在竞争时间结束前发完，就不能确定有没有冲突。\n\n\n\n\nBinary Exponential Backoff Algorithm 二进制指数回退算法\n\n一般地，在第i次冲突之后，从之间随机选择一个数，然后等待这么多个时间槽。然而，达到10次冲突之后，随机数的选择区间被固定在最大值1023，以后不再增加。在16次冲突之后，控制器放弃努力，并给计算机返回一个失败报告。\n\n\n无效的MAC帧\n\n\n\n\n\n4.3.3 以太网性能上面这张纯证明，可看可不看。下面这张要记住。ppt上只有结论：信道效率\n4.3. 交换式以太网\nHigh-speed backplan 高速背板\nCollision domain 冲突域\n由于每个冲突域只有一个站，碰撞是不可能的，性能得到了提高\n在集线器中，所有站都位于同一个冲突域(collision domain)， 它们必须使用CSMA/CD算法来调度各自的传输。在交换机中，每个端口有自己独立的冲突域。通常情况下，电缆是全双工的，站和端口可以同时往电缆上发送帧，根本无须担心其他站或者端口。现在冲突不可能发生，因而CSMA/CD也就不需要了。然后，如果电缆是半双工的，则站和端口必须以通常的CSMA/CD方式竞争传输。\n\n\n\n交换机的性能优于集线器有两方面的原因。首先，由于没有冲突，容量的使用更为有效。其次，也是更重要的，有了交换机可以同时发送多个帧(由不同的站发出)。这些帧到达交换机端口并穿过交换机背板输出到适当的端口\n帧被发送到输出端口还有利于安全。大多数LAN接口都支持混杂模式(promiscuous mode)，这个模式下所有的帧都被发到每台计算机，而不只是那些它寻址的机器。每个连到集线器上的计算机能看到其他所有计算机之间的流量\n有了交换机，流量只被转发到它的目的端口。\n4.3.5 快速以太网802.3u，对802.3的改进和补充，具有向后兼容性\n\n改进\n保留原有帧格式，接口和过程规则不变\n比特时间从100ns到10ns（10Mbps  100Mbps\n电缆最大长度降低\n统一使用双绞线或者光缆\n自动协商机制：两个站对速率（10Mbps or 100Mbps）以及双工模式（全双或者半双）\n\n\n\n100Base-T4 3类双绞线\n使用25mhz的信号\n\n需要4对双绞线(3类UTP)\n\n一对单向到集线器\n一对从集线器单向过来\n另外两对可切换到传输方向\n\n\n编码\n\n不使用曼彻斯特编码\n在一个时钟周期内发送三元信号(8B/6T编码，即8个二进制位转换为6个三元电平信号)\n27个可能的符号，传输4位\n\n\n一对双绞线的比特率是33.3Mbps，3对就是100Mbps\n\n\n\n100Base-TX 5类双绞线\n信号采用时钟125MHz\n需要2对双绞线(5类UTP)\n一对单向到集线器 用于发送\n一对从集线器单向过来 用于接收\n也就是全双工\n\n\n编码\n4B/5B（5个时钟周期发送4个比特）: 比特率：125 * 4/5 = 100Mbps\n\n\n\n100Base-FX 多模光纤    - 两根多模光纤，每个方向一根，实现全双工\nInterconnection Devices 互连设备\n集线器（半双工\n接入线逻辑连接，构成单个冲突域\n所有标准规则（包括二进制指数回退算法都适用）。所以可以像经典以太网一样工作\n集线器不允许使用多模光纤\n\n\n交换机\n传入的帧被缓冲并传递到目的地\n多模光纤（100Base-FX）对于碰撞算法来说过长，所以只能连到交换机（交换机没碰撞这回事\n\n\n\n4.3.6 Gigabit Ethernet 千兆以太网还是802.3的分支。\n\n改进\n\n比特时间从10ns到1ns（100Mbps  1000Mbps\n提供单播和广播的无确认数据报服务\n帧格式不变。\n还是48位寻址\n最小和最大帧尺寸不变\n\n\n\n\n交换机（全双工\n\n反正没竞争，所以没用CSMA/CD\n电缆的最大长度取决于信号强度\n交换机可以自由地混合和匹配各种速度\n支持自动配置特性（也就是配置速率，10、100、1000Mbps\n\n\n集线器（半双工\n\n有竞争，得用CSMA/CD\n对于64字节的最短帧，由于传输速率为经典以太网的100倍，所以最大电缆长度由2.5公里缩短为25米。\n发送变快了，得跟着变小\n\n\n载波扩展\n在普通帧的后面增加填充位（padding），将帧的长度扩充为512字节（发送方添加，接收方去除\n\n\n帧突发\n 允许发送方将多个待发送的帧拼到一起，一次传输；如果仍然小于512字节，则硬件会对其再次填充\n\n\n\n\n流量控制\n\n在流量控制机制下，一端的机器给另一端机器发送一个特殊的控制帧，告知对方暂停一段时间。这些暂停(PAUSE)控制帧是普通的以太帧，类型字段设置为0x8808。暂停时间是最小帧时的整数倍。 512ns~33.6ms\n\n\n\nppt还有一页是讲以太网为啥这么好使。\n应该不考，跳了。\n反正就是可靠便宜兼容性强那点东西\n4.3.7 10 Gigabit Ethernet 万兆以太网、用途\n\n4.4 无线局域网4.4.1 802.11体系结构和协议栈\n结构\n\n无线主机与基站通信\n基站(接入点)\n\n\n基本服务集(BSS)\n无线主机\n接入点(AP):基站\nad hoc mode:只允许主机访问\n\n\n\n\n802.11协议栈\n\n\n\n\n\n4.4.3 802.11 MAC子层协议802.11 MAC与以太网不同\n无线电总是半双工的\n接收到的信号比发送的弱106倍，碰撞检测机制不起作用\n所以采用 CSMA/CA\n\n当一个站点有一个帧待传输时\n\n等待信道空闲，检测并等待DIFS（DIFS是一段很短的时间\n随机后退（Random backoff(0~15 time slots)），然后倒计数空闲时间槽，当有帧在发送时暂停该计数器；当计数器递减到0该站就发送自己的帧。\n如果帧发送成功，目标站立即发送一个短确认。\n如果没有收到确认，则可推断出传输发生了错误，无论是冲突或是其他什么错。在这种情况下，发送方要加倍后退选择的时间槽数，再重新试图发送。\n\n\n和以太网的区别：和以太网相比，这里有两个主要区别。\n\n首先，早期的后退有助于避免冲突\n其次，利用确认来推断是否发生冲突，因为冲突无法被检测出来\n\n\n信道检测\n\n物理检测\n检查介质，看是否有有效的信号\n\n\n虚拟检测\n每个站可以保留一个信道何时要用的逻辑记录，这是通过跟踪网络分配向量(NAV, Network Allocation Vector)获得的。\n每个帧携帯一个NAV字段，说明这个帧所属的一系列数据将传输多长时间\n无意中听到这个帧的站就知道无论自己是否能够侦听到物理信号，由NAV所指出的时间段信道一定是繁忙的。\n\n\n\n\nRTS/CTS机制\n\n可选的RTS/CTS机制使用NAV来防止隐藏终端在同一时间发送。\n协议开始于当A决定向B发送数据时。A首先给B发送一个RTS帧，请求对方允许自己发送一个帧给它。如果B接收到这个请求，它就以CTS帧作为应答，表明信道被清除可以发送。一且收到CTS帧，A就发送数据帧，并启动一个ACK计时器。当正确的数据帧到达后，B用一个ACK帧回复A，完成此次交流。如果A的ACK计时器超时前，ACK没有返回，则可视为发生了一个冲突，经过一次后退整个协议重新开始运行。\n现在让我们从C和D的角度来看这次数据交流。C在A的范围内，因此它可能会收到RTS帧。如果收到了，它就意识到很快有人要发送数据。从RTS请求帧提供的信息，可以估算出数据序列将需要传多长时间，包括最后的ACK。因此，它采取了有利于所有人的做法，停止传输任何东西，直到此次数据交换完成。它通过更新自己的NAV记录表明信道正忙，如图4-27所示。D无法听到RTS，但它确实听到了CTS，所以它也更新自己的NAV。\n\n\n802.11和MACA的区别\n\n802.11中的RTS/CTS与我们在4.2节看到的MACA还是有点不同，因为每个站都能听到RTS或CTS，因而在此期间保持沉默以便ACK无冲突地通过。正因为如此，它无助于暴露终端问题的解决；正如MACA一样，只对隐藏终端有好处。大多数情况下隐藏终端很少，而且不管什么原因，CSMA/CA通过后退发送失败的站来缓解隐藏终端问题，使得传输更可能获得成功\n\n\n802.11的可靠性实现\n\n降低传输速率\n发送短帧（碎片帧\n\n\n\n 802.11允许把帧拆分成更小的单元一称为段(fragment)，每个段有自己的校验和。标准没有固定段的大小，但把它作为一个可以由AP调整的参数。这些段独立编号，使用停-等式协议\n\n 节能\n\n节能的基本机制建立在**信标帧(beacon frames)**基础上。信标帧由AP定期广播(例如每100毫秒发一个)。该帧向客户通告AP的存在，同时传递一些系统参数，比如AP的标识、时间(下一帧多久再来)和安全设置。\n\n客户端可以在它发送到AP的帧中设置一个电源管理位(power-management)，告诉AP自己进入省电模式(power-save mode)。在这种模式下，客户端可以打个盹，AP将缓冲所有发给该客户的流量。为了检查入境流量，客户端在每次信标帧来时苏醒过来，并检査作为信标帧一部分的流量图。\n\nAPSD 自动省电交付\n\n有了这个新机制，AP依然为休眠的客户端缓冲帧，但只在客户端发送帧到AP后才将其缓存的帧发送到客户端.这样一来，客户端可以安心进入睡眠状态，直到它有更多的流量需要发送(和接收)才醒来\n\n\nQOS：802.11中的帧间间隔\n\nDIFS：常规数据帧之间的间隔\nSIFS：\nACK帧\n其他控制帧比如RTS和CTS\n碎片帧\n\n\nAIFS1\n高优先级帧\n\n\nAIFS4 低优先级帧。后台流量一类\n\n\nQOS:TXOP\n\n帧大小相同时，当单独以6Mbps和54Mbps速率发送时，发送方将获得自己的速率\n两个站点：6Mbps和54Mbps，不使用TXOP，当它们一起发送时\n都达到5.4Mbps的平均水平.()\n此时标准：发送帧的大小相同\n\n\n两个站点：6Mbps和54Mbps，使用TXOP，当它们一起发送时\n分别得到3Mbps和27Mbps的吞吐量。（各自的速率除以站点的数量）\n此时标准：发送的时间相同\n\n\n\n\nMAC层的帧\n\n数据帧\n控制帧\nRTS,CTS,ACK\n\n\n管理帧\n信标和探针帧\n\n\n\n\n\n4.4.4 802.11帧结构\n数据帧的第二个字段为持续时间(Duration)字段，它通告本帧和其确认将会占用信道多长时间，按微秒计时。该字段会出现在所有帧中，包括控制帧，其他站使用该字段来管理各自的NAV机制。\n接下来是地址字段。发往AP或者从AP接收的帧都具有3个地址，这些地址都是标准的IEEE802格式。第一个地址是接收方地址，第二个地址是发送方地址。很显然，这两个地址是必不可少的，那么第三个地址是做什么用的呢?请记住，当帧在一个客户端和网络中另一点之间传输时，AP只是一个简单的中继点。这网络中的另一点也许是一个远程客户端，或许是Internet接入点。第三个地址就指明了这个远程端点\n\nppt上第三个地址给的例子是路由器。就当路由器把。 \n\n802.2: 逻辑链路控制 Logical Link Control我也不知道是哪一节。所以没写节号。\n\n802.2：LLC\n运行在802.3和其他802协议之上\n通过向网络层提供单一格式和接口，隐藏各种802网络之间的差异\n\n\nLLC提供三种不同的服务选项\n不可靠数据报服务\n或者叫最大努力数据报服务\n\n\nACK数据报服务\n有差错控制\n\n\n可靠的面向连接的服务\n有差错控制和流量控制\n\n\n\n\n\n\nLLC的位置和协议格式\n\n\n\n\n4.8 数据链路层交换\n802.x到802.y的网桥\n本地网络互连\n生成树网桥 Spanning Tree Bridges\n远地网桥 Remote Bridges\nRepeaters, Hubs, Bridges, Switches, Routers,Gateways\n虚拟局域网 Virtual LANs\n\n4.8.1 本地网络互连\n交互需要\n可能分布在几个建筑上\n将单个局域网分割成几个独立的局域网，以此来适应负载（多个冲突域\n物理距离2500m\n可靠\n安全\n\n4.8.2 看看网桥 \n \n自学习网桥（透明） Learning Bridge\n混杂模式运行\n\n接收在局域网上的每一帧\n\n\n站点表\n\n列出所有的可能的目的地并能分辨出其所在的局域网\n\n\n传入帧的发送过程\n\n如果目标局域网和源局域网相同，丢弃该帧（不需要转发\n如果不同，转发该帧\n如果目标局域网未知或者该帧是广播地址或者组地址，则使用泛洪算法\n泛洪算法：对于每个发向未知目标地址的入境，网桥将它输出到所有的端口，但它来的那个输入端口除外\n\n\n\n\n站点表：逆向学习\n\n初始化\n网桥刚接入的时候，所有的哈希表都是空的\n\n\n增加\n网桥在混杂模式下工作，所以可以看到每个发送帧的局域网\n通过观察帧的源地址，可以分辨局域网上哪些设备是可用的。\n若源站不在转发表中，那就将对应的MAC地址加入到转发表中，打上时间戳。若是已经存在，就更新时间戳\n\n\n\n\n动态拓扑\n\n当打开、关闭或者移动机器和桥时，网络的拓扑结构会发生变化。为了处理这种动态的拓扑结构，一旦构造出一个哈希表项后，帧的到达时间也被记录在相应的表项中。当帧到达时，如果它的源地址已经在表中，那么对应表项中的时间值被更新为当前时间。\n因此，与每个表项相关联的时间值反映了网桥最后看到该机器发出一帧的时间。\n在网桥中有一个进程定期扫描哈希表，并且将那些时间值在几分钟以前的表项都清除掉\n几分钟时间过长，意味着对应的拓扑结构大概率发生了改变，所以清掉。\n\n\n\n4.8.3 生成树网桥生成树用来解决网内循环。\n\n\n\n生成树算法\n\n为了建立生成树，网桥运行一个分布式算法。\n\n每个网桥周期性地从它的所有端口广播个配置消息给邻居，同时处理来自其他网桥的消息，处理过程如同下面描述的那样。\n\n这些消息不被转发，因为它们的用途是构建树，这棵树将被用于随后帧的转发。 \n\n全体网桥必须首先选择一个网桥作为生成树的根。为了作出这种选择，每个网桥在自己的配置消息中包含一个标识符，以及它们认为应该作为根的网桥的标识符。网桥标识符基于MAC地址，而MAC地址由网卡制造商预先设置好，能确保全世界独一无二。因此， 网桥标识符的生成既便利又具有唯一性。网桥选择具有最低标识符的网桥成为生成树的根。 经过足够的消息交换和扩散，最终所有网桥将都同意这个根\n\n然后，构造从根到每个网桥的最短路径树\n\n从根通过B2或B3都可到达B4，最短路径均为两跳。为了打破这种平局，选择一条经过具有最低标识符的网桥的路径，因此到达B4的路径通过B2。 \n\n为了找到这些最短路径，网桥在它们的配置消息中还包括与根的距离。每个网桥记住它找到的到根的最短路径。然后，网桥关闭那些不属于最短路径一部分的端口。\n\n\n\n\n4.8.4 中继器／集线器／网桥／交换机／路由器和网关\n\n中继器\n\n即物理层中， 我们可以看到有中继器。中继器是模拟设备，主要用来处理自己所连的线缆上的信号。在一个线缆上出现的信号被清理、放大，然后再被放到另一个线缆上。中继器并不理解帧数据包或帧头，它们只知道把比特编码成电压的符号。\n\n\n集线器\n\n集线器有许多条输入线路，它将这些输入线路连接在一起。从任何条线路上到达的帧都被发送到所有其他的线路上。如果两帧同时到达，它们将会冲突， 就好像它们在同一根同轴电缆上遇到后发生碰撞一样。连接到同一个集线器上的所有线路必须以同样的速度运行。集线器与中继器不同，它们(通常)不会放大入境信号，并且可以有多个输入线路\n\n\n网桥\n\n网桥连接两个或多个局域网。跟集线器一样，一个现代网桥有多个端口，通常具有4~48条某种类型的输入线。与集线器不同的是网桥的每个端口被隔离成它自己一个冲突域；如果端口是全双工的点到点线路，则需要用到 CSMA/CD算法。当到达一帧时，网桥从帧头提取出帧的目的地址，并用该地址査询一张应该把帧发往哪里去的表\n\n网桥比集线器提供了更好的性能，隔离网桥端口还意味着输入线路可以不同的速度运行，甚至可以是不同的网络类型。\n\n网桥最初是被用来连接不同种类的局域网，例如，把一个以太网和令牌环网连接在起。然而，由于不同局域网之间的差异，这方面的工作总是做得不是很好。\n\n\n\n交换机\n\n网桥倾向于连接相对数目较少的局域网，因而端口数也相对较少。现在”交换机”一词更为流行。此外，现代交换机的安装都使用了点到点链接(例如双绞线)，单个计算机通过双绞线直接插入到交换机端，因此交换机的端口数往往有许多个。\n\n交换机是现代网桥的另一个称呼。它们的差异更多地体现在市场上而不是技术方面。\n\n\n\n\n下面这个比较重要\n\n路由器\n\n当一个数据包进入到路由器时，帧头和帧尾被剥掉，帧的有效载荷字段中(如图4-45中的阴影部分)的数据包被传给路出软件。路由软件利用数据包的头信息来选择输出线路。对于一个IP数据包，包头将包含一个32位(IPv4)或者128 位(IPv6)地址，而不是48位的IEEE802地址。\n\n\n传输网关\n\n再往上一层我们可以发现传输网关。它们将两台使用了不同面向连接传输协议的计算机连接起来。\n\n\n应用网关\n\n最后，应用网关能理解数据的格式和内容，并且可以将消息从一种格式转换为另一种格式\n\n\n\n4.8.5 虚拟局域网\n广播风暴\n局域网的容量会被这些广播帧占据\n设备仅仅处理和丢弃这些帧就会发生瘫痪\n\n\n\n所以将一个局域网分割成几个虚拟局域网。\n\nVLAN和配置表\n\n为了使VLAN正常地运行，网桥必须建立配置表。这些配置表指明了通过哪些端口可以访问到哪些VLAN。当一帧到来时，比如说来自灰色VLAN，那么这帧必须被转发到所有标记为G的端口。这一条规则对于网桥不知道目的地位置的普通流量(即单播)以及组播和广播流量都适用。注意，一个端口可以标记为多种VLAN颜色。\n\n\nVLAN帧格式\n\n\n\n\nVLAN感知\n\n\n\n\n\n","tags":["计网"]},{"title":"形式语言与自动机前半期","url":"/2022/04/19/automata_1/","content":"整理到第三章结尾，期中考试前。\n随便写写。\n第一章没有。\n没标粗那就不是重点，速通的话不用看。\n标粗也不一定是，也可能是因为我觉得这里标粗了更好看。\n第二章 语言及文法第一节 语言\n字母表： 字符的有限集合，记为T。 \n形式符号的集合\n常用 T、 表示\n\n\n\n\n字符串： 字母表 T 上的一个字符串（简称串），或称为字（word），为 T 中字符构成的一个有限序列。  \n空串（empty string）, 用 表示，不包含任何字符\n常记为u,v,w,x,y,z；\n常用a,b,c,d 标识单个字符。\n字符串 w 的长度，记为 |w| ，是包含在 w 中字符的个数。 \n\n\n\n\n连接：设 x, y为串, 且 x = a1a2 … am, y = b1b2 … bn,则 x 与 y 的连接  x y = a1a2 … am b1b2 … bn\\\n连接运算的性质：\n( x y ) z = x（ y z ）\n x = x  = x \n| x y | = |x|+|y| \n\n\n\n\n设ω1, ω2, ω3是字母表T上的字符串，称ω1是字符串ω1ω2的前缀，ω2是字符串ω1ω2的后缀，且ω2是字符串ω1ω2ω3的子串。 \n空串是任何字符串的前缀，后缀及子串。\n字符串ω的逆用表示。 是字符串ω的倒置。\n空串ε的逆还是ε\n\n\n幂运算：设 T 为字母表，n 为任意自然数，\n定义\n  = {}\n 设 x ，a  T， 则a x \n  中的元素只能由（1）和（2）生成\n\n\n*闭包： \n+闭包：\n\n\n\n\n\n语言： 设 T 为字母表，则任何集合 L  T* 是字母表T上的一个语言（language）\n语言的积：两个语言L1 和L2的积L1 L2是由L1和L2中的字符串连接所构成的字符串的集合。即L1中所有字符串分别与L2中的字符串连接得到的集合。\n语言的幂：    \n语言的幂可归纳定义如下: = {ε}\n注意这里有个左右翻转\n\n\n\n\n\n\n\n第二节 文法\n定义：所谓文法是用来定义语言的一个数学模型\n\n表示语言的方法：\n\n若语言L是有限集合，可用列举法\n若L是无限集合（集合中的每个元素有限长度），用其他方法。\n方法一：文法产生系统，由定义的文法规则产生出语言的每个句子\n方法二：机器识别系统：当一个字符串能被一个语言的识别系统接受，则这个字符串是该语言的一个句子，否则不属于该语言。\n\n\n\n\n元语言：描述语言的语言。例如：各种各样的程序设计语言\n\n 当人们要解释或讨论程序设计语言本身时，又需要一种语言，被讨论的语言叫做对象语言，即某种程序设计语言，讨论对象语言的语言称为元语言。\n\n\nBNF（巴科斯范式）：BNF范式通常被作为讨论某种程序设计语言语法的元语言\n\n::= “定义为”\n&lt;数字&gt; ::= 0|1|2|……9 \n&lt;字母&gt; ::= A|B|C|……Z|a|b|……z        \n&lt;标识符&gt; :: =&lt;字母&gt; | &lt;标识符&gt;&lt;字母&gt; | &lt;标识符&gt;&lt;数字&gt;\n通过上述定义可知，所有以字母开头的，由字母和数字组成的字符串都是标识符。\nBNF定义了一种语言，其中标识符如上定义。\nBNF描述它所定义的语言，为元语言。\n\n\n  文法是一种元语言，一种方法，根据文法产生出语言的句子。\n\n\n\nChomsky文法体系：\n相较于BNF，其中:=用代替，分别用I，L，D表示标识符、字母、数字\n\n所以把BNF表示的再用Chomsky表示一遍，如下：\n\nI→L\nI→L\nI→ID\nL→a|b|….|z\nD→0|1|….9\n\n\nChomsky文法体系中，任何一种文法必须包含有两个不同的有限符号的集合，即非终结符集合N和终结符集合T。一个形式规则的有限集合P（生成式集合），一个起始符S。\n\nP中的生成式是用来产生语言句子的规则，而句子则是仅由终结符组成的字符串。这些字符串必须从一个起始符S开始，不断使用P中的生成式而导出来。\n\n可见文法的核心是生成式的集合，它决定了语言中句子的产生。\n\n我终于知道为什么自动机ppt符号基本是错的了。属于是直接把电子教材的文本拷贝到ppt里，也不管符号编码对不对上。倒是方便我做笔记了，直接复制粘贴就行了。\n\n\nChomsky文法的形式定义：文法G是一个四元组G=(N，T，P，S)，其中\n\nN  非终结符的有限集合\nT  终结符的有限集合   \nP 形式为的生成式的有限集合。\n且\n\n\nS  起始符  且S ∈N。\n\n\n\n推导与句型\n直接推导：\n设G =（N,T,P,S）是文法，若A→β是P中的生成式，α和γ是（N∪T）*中的字符串，则有αAγ=&gt; αβγ称αAγ直接推导出αβγ，或说αβγ是αAγ的直接推导。\n\n\n推导序列：\n设G = (N,T,P,S)是文法，α、α0、α1…αn、α’都是（N∪T）中的字符串，且α=α0、 α’ =αn，其中αi直接推导出αi+1 （0≤i≤n）,则称序列α0=&gt;α1=&gt;α2=&gt;…=&gt;αn是长度为n的推导序列，*而α=α0是长度为0的推导序列。\n对α推导出α’记为αα’ ，若推导序列长度大于0，则记为α  α’。\n推导序列的每一步，都产生一个字符串，这些字符串一般称为句型。\n\n\n\n\nChomsky文法体系分类\n该体系对生成式（产生式）的形式做了一些规定，分为四类，即0型、1型、2型、3型文法\n\n0型文法：无限制文法  对应的语言：递归可枚举语言，与图灵机等价。\n\n1型文法:也称上下文有关文法（CSG：Context-sensitive Grammar)\n\n生成式的形式为α→β，\n其中 |α|≤|β|，β∈（N∪T）+，  \nα∈（N∪T）N+（N∪T）*\n\n\n限定约束：\n左部的长度小于右部\n不含A-&gt;ε\n\n\n\n\n2型文法：也称上下文无关文法（CFG：Context-free Grammar)\n\n A→α, \n A∈N, 且α∈（N∪T）*\n 左部是单个非终结符。\n\n\n3型文法：\n\n右线性文法（Right-linear Grammar）：A→ωB 或 A→ω\n    A、B∈N, ω∈T*。\n\n\n左线性文法（Left-linear Grammar）：A→Bω或 A→ω\n        A、B∈N, ω∈T*。\n\n\n对应的语言：正则语言\n对应的自动机：有限自动机（Finite Automaton）。\n\n\n四类文法之间的关系   \n\n0型   无限制\n1型   不允许A→ε形式\n2型\n3型   属于2型\n不含A→ε的2型、3型属于1型，1型、2型、3型均属于0型。\n\n\n\n第三章 有限自动机与右线性文法第一节 有限自动机\n有限自动机的概念：\n\n具有离散 输入 输出系统的一种数学模型(可以没有输出，比较特殊的也可以没有输入).\n有限的状态\n后继状态唯一：DFA\n后继状态不唯一：NFA\n\n\nFA的模型：FA可以理解成一个控制器，它读一条输入带上的字符。\n\n\nDFA的形式定义\n定义: DFA是一个五元组 M=(Q,T,δ,q0,F)\n\nQ: 有限的状态集合\nT: 有限的输入字母表\nδ: 转换函数(状态转移集合): Q×T  Q\nq0: 初始状态， q0  Q\nF: 终止状态集,  F  Q\n\n\nδ’函数：接收一个字符串的状态转移函数。\n\n对任何q  Q，定义：\n\n若ω是一个字符串, a是一个字符定义: δ’(q,ωa)=δ(δ’(q,ω),a)\n\n\n\n\nDFA接收的语言：\n\n被DFA接收的字符串: 输入结束后使DFA的状态到达终止状态。否则该字符串不能被DFA接收.\nDFA接收的语言: 被DFA接收的字符串的集合.\n\n\n格局：为描述有限自动机的工作过程，对于它在某一时刻的工作状态，可用两个信息表明：当前状态q，待输入字符串w。两者构成一个瞬时描述，用（q,w）表示，称为格局。\n\n初始格局：（q0,w)\n终止格局：  (q,ε), qF\n描述格局的这个符号长得还挺奇特\n\n\n\n\n\n第二节 不确定的有限自动机NFA修改DFA的模型，使之在某个状态， 对应一个输入，可以有多个转移， 到达不 同的状态， 则称为不确定的有限自动机。\n\nNFA是一个五元组，M=(Q,T,δ,q0,F)。  其中δ是的函数，其余与DFA相同\n如果接收一个字符串后NFA进入一个状态集，而此集合中包含一个以上F中的状态， 则称NFA接收该字符串。\n用格局描述NFA，则要分别描述每个可能的状态：\n\n\n\n第三节 NFA和DFA的等价性定理：设一个NFA接受语言L，那么必然存在一个DFA接受L。\nNFA构造DFA 子集构造法\n\n表示初态，*表示终态\n\n\n 实践中, 通过子集构造法得到的 DFA 的状态数目与原NFA 的状态数目大体相当.\n 在较坏的情况下,上述 DFA 的状态数目接近于所有子集的数目.  \n\n\n证明不放了。估计不考。\n\n第四节 有转换的NFA\n定义：概念：当输入空串(无输入) 时，也能引起状态的转移。\n\n的形式定义： 一个 是一个五元组 .\n\n与 NFA 的不同之处 \n\n\n\n闭包的概念\n 状态 q 的 - 闭包，记为   - CLOSURE 或ECLOSE ，定义为从 q  经所有的 路径可以到达的状态（包括q自身）\n\n状态子集I\n\n概念：\n\n其中，. 即P是从I中的状态经过一条标a的边可以到达的状态集合 \n即\n\n\n\n\n扩展转移函数适合于输入字符串\n\n注意一下这个注意\n\n\n\n从NFA构造等价的无NFA关键点就一句话：δ1’（q0，ω）含F1的一个状态当且仅当δ’（q0， ω）含F的一个状态这里F1指的是带,F是指不带的。\n抽道题：\n过程差不多就是遍历T，保证对于所有可以到达的状态，也可以通过相同符号到达就行了。\n\n还要注意的就是，如果起始状态的闭包里有终止状态，那NFA里要把起始状态改成终止状态顺便我个人建议，对于中的闭包。直接改成对于T中所有字符都可以到达就完事了，可以提前省很多麻烦。\n\n第五节 正则集和正则式\n正则集：字母表上一些特殊形式的字符串的集合，是正则式所表示的集合。\n\n正则式：用类似代数表达式的方法表示正则语言。\n\n归纳正则表达式如下：\n\nε，，a （a∈T）都是正则式 (原子正则式) ，  相应的正则集为{ε}，，{a}\n如果A和B是正则式，且分别代表L(A)和L(B).则(A+B)，(AB)，  A* 也是正则式，分别表示以下正则集\nL(A) ∪L(B)             (语言A / 语言B的串)\nL(A) • L(B)              (两个语言中的串的连接)\n L(A) *                  (语言A中的串的多次连接)\n\n\n\n\n正则式的性质：    \n\n幺元这个东西感觉有点玄幻  然后这个东西在因式分解的时候当1使\n\n\n\n右线性文法导出正则式右(左)线性文法又称为正则文法，右线性文法与正则式可以用来代表同一正则语言。二者具有等效性。\n求解规则R：设x = αx+β，α∈T，β∈(N∪T), x∈N则x的解为 ＝\n设右线性文法G=({S,A,B},{a,b},P,S}，生成式P如下： S→aA , S→bB, S→b, A→bA, A →, B→bS \n以上生成式写成联立方程为    S=aA+bB+b    （1）    A=bA+            （2）    B=bS                （3）\n对式（2）利用规则R和性质 α  = α得     A=b*  （4）将式（4）和式（3）代入式（1）中的A、B，得    S=ab*+bbS+b=bbS+ab*+b=(bb)(ab+b)所以由G产生的语言用正则式表示为  (bb)(ab*+b)\n第六节 正则集和右线性文法 正则集是由右线性文法产生的语言 由右线性文法产生的语言都是正则集\n证明略了。\n提了两句互相转换。\n正则集右线性文法：找出相应的右线性文法，使之产生的语言是这些正则集。\n\n也就是说没啥好方法，看点子\n\n右线性文法正则集：对右线性文法构造标准形式的正规表达式方程组，应用规则＝＝进行消元，求解方程组，即可得出正规表达式。\n定理: 一个语言是正则集，当且仅当该语言为右线性语言。\n正则集到有线性文法的例子：\n\n第七节 正则表达式与有限自动机的关系 有限自动机、右（左）线性文法、正则表达式都定义了同一种语言– 正则语言.\nDFA构造等价的正则表达式\n扩展自动机的概念，允许正则表达式作为转移弧的标记。 这样，就有可能在消去某一中间状态时，保证自动机能够接受的字符串集合保持不变\n在消去某一中间状态时，与其相关的转移弧也将同时消去，所造成的影响将通过修改从每一个前趋状态到每一个后继状态的转移弧标记来弥补。 \n\n\n步骤：eg:\n从正则表达式构造等价的\n定理:  L 是正则表达式 R 表示的语言, 则存在一个 - NFA E ,满足 L(E) = L(R) = L.\n\n构造：\n\n\n\n就是用一大堆。能用的全用上了。\n\neg：\n上述表明三种定义正则集的方式：\n\n正则表达式\n右线性文法\n正则集是含有{ε}，，{a} 以及在并、连接和 * 运算下封闭的语言\n完事了还有第四种，可以用自动机定义。挺明显了上面讲了一大堆自动机和正则式的转换\n\n右线性文法  有限自动机看题就懂了。\n\n注意要单独捏造一个最终状态\n对于右边接的是字符串的，单独开个状态：\n有限自动机 右线性文法看题就懂了。\n第九节 右线性语言的性质确定有限自动机DFA的化简简单来说就是先将不可达状态删了之后，把同一分区的都合并。\n\n等价和可区分：\n设DFA  M = (Q，T，δ，q0，F)\n对不同的状态q１， q２∈Q 和每个ω∈T*，如果有(q１，ω)┣ (q，ε) 和 (q２，ω)┣ (q，ε) 且q∈F，则称q１与q２状态等价. 记为q１≡q２否则，称q１， q２可区分。\n\n\n\n\n不可达状态：如果不存在任何ω∈T，使(q０，ω)┣* (q，ε)，则称状态q∈Q为不可达状态。\n最小化：  若DFA Ｍ不存在互为等价状态及不可达状态，则称DFA Ｍ是最小化的。\n\n区分的第一步是把最终态和非最终态区分出来，之后顺着来。先给个硬看硬分的写法：\n然后填表算法，这个简单,也用的多：\n步骤：\n\n删除所有从开始状态不可到达的状态及与其相关的边, 设所得到的 DFA 为 A = (Q, T, , q0 , F ) ；\n使用填表算法找出所有等价的状态偶对；\n根据 2 的结果计算当前状态集合的划分块，每一划分块中的状态相互之间等价，而不同划分块中的状态之间都是可区别的. 包含状态 q 的划分块用 [q] 表示.\n构造与 A 等价的  , 其中\n注意优化后的状态要加小框框\n\n\n\n针对正则语言的Pumping引理\n定理：设L是正则集，存在常数k，对字符串ω∈Ｌ 且｜ω｜≥ｋ，则ω可写成ω1ω0ω２，其中｜ω1ω0｜≤ｋ，｜ω0｜＞０，对所有的ｉ≥0有ω1ω0iω2∈Ｌ。\n\n证明：设 L 是 DFA  D = (Q, T, , q0 , F ) 的语言， 取 k = |Q| 即可. \n\n\n\n用了个鸽巢。意思还是很清晰的。\n\n\n\n\n\n泵浦引理的应用基本就是用来证明某个语言L不是正规语言。\n步骤：\n\n选任意的n.\n找到一个满足以下条件的串wL (长度至少为n).\n任选满足w = xyz  y   |xy|  n 的x,y,z\n找到一个 k 0,  使 .\n\neg\n右线性语言的封闭性\n∪\n\n\n\n∩\n  \n\n\n幂\n\n\n\n逆\n\n\n\n\n\n","tags":["形式语言与自动机"]},{"title":"计网数据链路层","url":"/2022/04/17/jiwang_3/","content":"一更，根据作业的范围加了点东西,划了下重点。\n笔记来源和物理层一致，教材ppt和大爹。\n没有一张图是自己截的。\n3.1 数据链路层的设计问题\n数据链路层的功能\n向网络层提供一个定义良好的服务接口\n处理传输错误。\n调节数据流，确保慢速的接收方不会被过快的数据流淹没。\n\n\n\n3.1.1 提供给网络层的服务\n数据包和帧的关系\n\n提供的服务类型\n\nUnacknowledged connectionless service. 无确认无连接\nAcknowledged connectionless service. 有确认无连接\nAcknowledged connection-oriented service 有确认有连接（面向连接的服务\nConnection establishment\nTimer\nSequence number\n\n\n\n\n\n3.1.2 FramingCharacter Count字符计数\n这种成帧方法利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节，因此也就知道了该帧在哪里结東。\n但如果计数的头字符出错了后面就全都错了。如图：\n\nByte Stuffing字节填充的标志字节法\n第二种成帧方法考虑到了出错之后的重新同步问题，它让每个用一些特殊的字节作为开始和结朿。这些特殊字节通常都相同，称为标志字节(flag byte)，作为帧的起始和结束分界符，如图3-4(a)中的FLAG所示。两个连续的标志字节代表了一帧的结束和下帧的开始。\n\n问题：发送的信息含有很多控制字符，需要转译的字符大大增加开销：overhead，跟需要发送的数据相比，额外添加的转义字符所占的比例，比如全是需要转译的字符的信息，overhead就是100%。\nBit Stuffing比特填充的标志比特法\n每个帧的开头结尾都是一个special bit pattern, 01111110 ，也就是16进制的7EH，当数据内容出现连续的1时，每遇到五个1添加一个0（硬件不管这5个1后面是0还是1），接收方做相反的工作。\n\n(a) The original data.(b) The data as they appear on the line.(c) The data as they are stored in receiver’s memory after destuffing.\nPhysical Layer Coding Violations物理层编码违例法\n比特编码成信号一般会包括一些冗余比特，以方便接收器同步接收。\n我们可以利用这些保留的信号来指示帧的开始和结束。实际上，我们使用”编码违法”来区分帧的边界。这种方案的优点在于，因为这些用作分界符的信号是保留不用的， 所以很容易通过它们找到帧的开始和结束，而且不再需要填充数据。\n例如：对于曼彻斯特Manchester编码，两个跳变表示一个bit，所以当出现长高电平，常低电平，就属于物理层违例了，可以作为帧的边界。\n3.1.3 Error Control确保可靠传递的常用方法是向发送方提供一些有关线路另一端状况的反馈信息。通常情况下，协议要求接收方发回一些特殊的控制帧，在这些控制帧中，对于它所接收到的帧进行肯定的或者否定的确认\n当发送方发出一帧时，通常还要启动一个计时器。该计时器的超时值应该设置得足够长，以便保证在正常情况下该帧能够到达接收方，并且在接收方进行处理后再将确认返回到发送方。一般情况下，在计时器超时前，该帧应该被正确地接收，并且确认帧也被传了回米。这种情况下，计时器被取消。\n然而，如果帧或者确认被丢失，则计时器将被触发，从而警告发送方存在一个潜在的问题。一种显然的解决方案是重新发送该帧。然而，当有的帧被发送了多次之后，可能会出现这样的危险：接收方将两次或者多次接收到同一帧，并且多次将它传递给网络层。为了避免发生这样的情形，一般有必要给发送出去的帧分配序号，这样接收方可以根据帧的序号来有效区分原始帧和重传帧。\n一条消息第k次发送成功的概率为p，问期望发送次数\n3.1.4 Flow Control\n两种流量控制\n\n基于反馈信息的流量控制 feedback\n基于速率的流量控制（主要是网络层，一种内嵌的机制，浅显的理解是限制速率）rate-based\n\n\n流量控制协议\n\n停等 Stop And Wait\n滑动窗口 Sliding Window\n\n\n\n3.2 差错检测和纠正\n错误分类\nlost frames：一个数据帧完全没能传过去，常常是因为噪音或者掉队\ndamaged frames：一些bit错了\n\n\n差错检测\n奇偶校验码(parity):检测单比特错误\n循环冗余校验。Cyclic Redundancy Check:CRC: detecting some burst errors\n自动重发请求。Atuomatic Repeat reQuest:ARQ\n\n\n差错纠正\n前向纠错 FEC\n\n\n\n\n3.2.1 纠错码书上四种纠错编码。只考察海明和奇偶。\n海明码\n补充：海明距离Hamming两个编码异或之后为1的位数检测到d个errors，需要distance为d+1的编码纠正d个errors，需要distance为2d+1的编码这里的距离指的是码表上任意两个编码之间的hamming距离，取最小。对于已知的检错方法，要确定能够检测出几个error应该考虑最坏的情况。\n\n\nm:数据位数r：所需的校验位由该式可以解出需要的最少校验位\n\n字很潇洒。不是我的。\n来到纠错最高城海明，哎呀这不简便算法吗。\n\n还是看看远方的样例吧家人们\n\n这是最多一位出错的基础上的算法。\n突发出错海明能不能纠错呢，ppt上说可以，但没说咋可以，教材没说。\n那就当它不行，我估计不会考海明对多位纠错。\n顺便看道题：\n\nTo provide more reliability than a single parity bit can give, an error-detecting coding scheme uses one parity bit for checking all the odd-numbered bits and a second parity bit for all the even-numbered bits. What is the Hamming distance of this code?这道题默认不加校验码的时候原编码的海明距离是1，也就是仅靠原编码本身不可以检验错误。有了这个条件题目答案才很明显，加了校验码之后编码的海明距离是2。因为最多一位原编码部分不同，和一位校验码部分不同。\n\n3.2.2 检错码Checksum 校验和校验和（checksum）这个词通常用来指与信息相关的一组校验位，不管这些校验位是如何计算出来的。一组奇偶校验位是校验和的一个例子。然而，还有其他种类的校验和，强大的校验和基础是对消息中的数据位进行求和计算。校验和通常放置在消息的末尾，作为求和功能的补充。这样一来，通过对整个接收到的码字(包含了数据位和校验和)进行求和计算就能检测出错误。如果计算结果是零，则没有检测出错误。\n\n奇偶校验码即是一位校验和，现在常用的是十六位校验和一个书上没有但作业里有的知识点：单个位的丢失、插入或修改会导致n位校验和出错的概率是。我不知道这个咋算的，记住就行。\n\n\n交错校验（interleaving）：\n我们将为n列中的每列计算校验位，按k行发送全部的数据位，发送次序是从上到下发送每一行，行内数据位通常按从左到右的次序发送。在最后一行，发送n个校验位。\n交错校验是一种将检测(或纠正)单个错误的编码转换成能检测(或纠正)突发错误的通用技术。\n\n\n\nCRC 循环冗余校验大爹来了。\n这玩意儿应该是属于多项式编码的。  Polynomial Code \n多方参考了觉得我之前做的笔记里写的最清楚\n所以照抄。\n提一嘴，这玩意儿是模2除法，也就是直接异或，不是正常的除法。\n\n\n\n\n\nCRC的性能所有的一位错误都将被检测到\n可以捕捉到所有包含奇数个位变反的错误情形\n带r个校验位的多项式编码可以检测到所有长度小于等于r的突发错误。\n若让（x+1）是G(X)的一个因子（factor），则所有的奇数位都可以检测出来，\n如果突发错误的长度为r+1，这样一个不正确的帧被当做有效帧接收的概率是\n同样可以证明，当一个长度大于r+1位的突发错误发生时，或者几个短突发错误发生时，一个坏帧被当做有效帧通过检测的概率为\n\n我哪知道咋证。反正大爹是这么说的。\n\n为啥把CRC校验码放到帧尾：如果放在帧头，则要在发送前扫描帧，计算完CRC后再从帧头开始发送。若放到帧尾，可以一边发一边计算。最后直接将CRC发送出来。\n3.3 基本数据链路层协议有请大爹笔记。\n一些假设\n假设物理层、数据链路层和网络层都是独立的进程，它们通过来回传递消计算机操作系统网络接口卡息进行通信\n机器A希望用一个可靠的、面向连接的服务向机器B发送一个长数据流。\n假设机器不会崩溃。\n假设有一个现成的代码，其中过程to_physical_layer发送一帧，from_physical_layer接收一帧。这些过程负责计算和附加校验和，并检查校验和是否正确(这部分工作通常由硬件完成)，\n一些声明\n\n3.3.1 一个乌托邦式的单工协议无差错的channel，完美的接收者，源源不断的发送\n\n就几行，基本就是网络层交互，缓存和物理层交互。没啥可说的。\n3.3.2 无错信道上的单工停等协议现在我们将处理这样的问题：发送方以高于接收方能处理到达帧的速度发送帧，导致接收方被淹没。这种情形实际上很容易出现，因此协议是否能够防止它非常重要。然而， 我们仍然假设通信信道不会出错，并且数据流量还是单工的。\n也就是考虑flow control，仍然是完美的信道\n\n多了个发送和等待确认帧的过程。其他的没啥区别\n3.3.3 有错信道的单工停等协议序号简化\n一位序号(0或者1)就足以解决问题。在任何一个时刻，接收方期望下一个特定的序号。当包含正确序号的帧到来时，它被接受下来并且被传递给网络层。然后，接收方期待的下一个的序号模2増1(即0变成1，1变成0)。任何一个到达的帧，如果包含了错误序号都将作为重复帧而遭到拒绝。不过，最后一个有效的确认要被重复，以便发送方最终发现已经被接收的那个帧。\n自动重复请求(ARQ, Automatic Repeat request)如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议称为自动重复请求(ARQ, Automatic Repeat request)或带有重传的肯定确认(PAR, Positive Acknowledgement with Retransmission)\n重传机制的肯定确认协议\n上面这个是没考虑差错控制的，考虑差错控制的肯定确认协议如下：Sender: 从网络层获取一个分组放入buffer发送buffer中的数据，新启动定时器label1:wait_for_event()switch (event) {case 收到了坏帧(校验和错):     重发缓冲在buffer里的数据，重新启动定时器     //这里的\"重新\"和\"新\"都是指从头开始启动计时器case 定时器超时：     重发缓冲在buffer里的数据，新启动定时器case 收到校验和正确的帧：     if（ack序号正确） {        关闭旧定时器        从网络层获取下一个分组放入buffer        发送buffer中的数据，新启动定时器     } else          重发缓冲在buffer里的数据，重新启动定时器}goto label1\n Reciver: frame_expected=0while(true) {   wait_for_event()   switch(event) {   case 坏帧：      do_nothing   case 收到校验和正确的数据帧:      if（序号==frame_expected） {         向网络层上交分组         回ACK（序号为frame_expected)         inc(frame_expected)      }  else {         回ACK（序号为frame_expected-1)      }   }}\n3.4 滑动窗口协议Sliding Window!\n\nPiggyBacking\n当到达一个数据帧时，接收方并不是立即发送一个单独的控制帧，而是抑制自己并开始等待，直到网络层传递给它下一个要发送的数据包。然后，确认信息被附加在往外发送的数据帧上(使用帧头的ack字段)。实际上，确认信息搭了下一个出境数据帧的便车。这种暂时延缓确认以便将确认信息搭载在下一个出境数椐帧上的技术就称为捎带确认(piggybacking)\n\n\n\n发送窗口和接收窗口的定义一大段，懒得放了。\n\n3.4.1 1位滑动窗口协议用的是捎带确认，双工。\n\n除了捎带以外跟停等没太大区别。\n3.4.2 回退N帧协议 GBN这一块ppt跟大爹笔记都挺乱的。\n我随便写写意思意思。\n\n累积确认：对于采用GBN的接收方，可以采用累积确认的方式。即接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定），对按序到达的最后一个数据分组发送确认。表示序号为n之前的所有数据分组都已经被正确接收。\n\n累积确认的一个好处是ACK丢失的影响会变小，有时即便确认分组丢失，发送方也不必进行数据分组重传.\n\n\n计时器：因为协议5有多个未被确认的帧，所以逻辑上它需要多个计时器，即每一个未被确认的帧都需要一个计时器\n\n\n捎带确认，累积确认。\n\n3.4.3 选择重传协议由于GBN的只能等于1，因此一个数据分组的误码会导致后续多个数据分组不被接收而被丢弃。这会导致发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。为了进一步提高性能，可以设法只重传出现误码的数据分组，因此，接收窗口尺寸应当大于1.以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组。等到所缺分组收齐后再一并送交上层。这就是选择重传协议\n\n注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。\n\n\n\n其中的取数规则和GBN不同，而。\n\n我上次的笔记这里写错了。检查一下改过来。\n\n接收方只要接收了相应的分组，都会对发送方发送确认分组。但只有在按序接收的情况下，接收窗口才会向后滑动。而发送方只要接收到了确认分组，都会对相应的数据分组进行标记，以表明该分组已经发送成功。但只有在按序标记完的情况下，发送窗口才会向后滑动。\n同时选择重传协议的代码中引入NAK\n在SR协议中，发送端对每一个发送帧都配备了一个ACK辅助计时器。这些辅助计时器通常不是同时启动，因此每次发生超时事件的时候都是只有一个ACK辅助计时器超时，那么这个时候只重发一个帧。\n当接收方有理由怀疑出现了错误时，它就给发送方返回一个否定确认(NAK)帧。这样的帧实际上是一个重传请求，在NAK中指定了要重传的帧。在两种情况下，接收方要特别注意：接收到一个受损的帧，或者到达的帧并非是自己所期望的(可能出现丢帧错误)。为了避免多次请求重传同一个丢失帧，接收方应该记录下对于某一帧是否已经发送过NAK。\n\n\n注意：SR协议里的MAX_SEQ不可以是偶数。如果是偶数，因为向零舍入，导致(MAX_SEQ+1)/2 = (MAX_SEQ)/2 = NR_BUF 。而 0%NR_BUF = MAX_SEQ%NR_BUF，也就是说当接收窗口横跨MAX_SEQ和0时，这二者共用同一块缓存。此时可能导致上传网络层的包顺序错误。（即当MAX_SEQ帧丢失，0号帧到达，会直接上传0号帧。\n\nPerformance of  Sliding Window ProtocolsPPT中间插的一节\n没啥东西，背公式的。\n传播时延发送时延。知道这个就嗯套就完事了\nStop-and-wait   without error\n\n所以传播距离较短的时候SW还是蛮牛逼的\n\nStop-and-wait   with error\nSlide window   without error上面的这是不考虑piggybacking的效率\n考虑Piggybacking:  U=N/(2+2a)\n3.5 数据链路协议实例HDLC不咋重要。考试知道有这玩意儿就行了\nSLIP不咋重要。考试知道有这玩意儿就行了\nPPP这个要考，比前两个重要很多。\n\n字节填充 byte stuffing\n\nppp协议使用软件实现，而软件实现字节填充比实现字填充更方便\n\n\nCRC校验 FCS\n\n无序号 无流量控制和差错控制\n\n提供无连接无确认的服务\n\nPPP提供的服务：\n\n定义设备之间要交换的帧的格式\n定义两个设备怎么协商建立链路和交换数据\n定义如何将网络层的数据封装到数据链路层的帧里\n定义两个设备怎么相互鉴别\n\n\nPPP的三个组成部分\n\n成帧方法：网络层数据封装到串行链路的方法\n链路控制协议LCP\n网络控制协议NCP\n\n\nPPP子层\n\n\n\n\nPPP帧格式\n\n\n\n\n\n\n最小开销：两个标志字节，一个协议字节，两个校验字节，共五个字节最大开销：两个标志字节，一个地址字节，一个控制字节，两个协议字节，四个字节，共十个字节\n\n标志字节如果出现在Payload字段，则要用转义字节0x7D去填充；然后将紧跟在后面的那个字节与0x20进行XOR操作，如此转义使得第6位比特反转。例如0x7D0x5E是标志字节0x7E的转义序列。这意味着只需要简单扫描0x7E就能找出帧的开始和结束之处因为这个字节不可能出现在其他地方。接收到一个帧后要去掉填充字节。具体做法是，扫描搜索0x7D，发现后立即除；然后用0x20对紧跟在后面的那个字节进行XOR操作。\nPPP协议相图\n\n\n\n\n","tags":["计网"]},{"title":"Go实现NFA转DFA","url":"/2022/04/14/GO_4/","content":"自动机的弱智实验。\n组里有人发了个前几年别人写的C++实现。\n瞟了眼感觉没咋用C++的继承多态派生友元的特性，也不咋面向对象。想了想觉得能用Go改，所以试试。\n改了下发现他那个写的真不行。三百多行里头起步五十多行没啥用，套了好几个没啥用的循环。实现思路也挺暴力的。\n最重要的是不写注释，变量起名也莫名其妙，一大堆temp。我估计他自己现在都看不懂了。\n看了眼把他思路弄明白了就直接Go开写了。Go的特性简化了很多流程，总体来说比他的优化了不少。一晚上弄完了，回头还打了把哈迪斯。\n看看用了啥包被import (\t\"fmt\"\t\"io/ioutil\"\t\"os\"\t\"strings\")\nfmt不说了。这个不放进来那也别写了。\nio用来文件输入输出。毕竟那一大堆弱智输入总不能指着用户手输把。\nos光用来exit了。一只手数的过来的错误检测。\nstrings处理一下输入输出的行。\n搞搞输入输出输入这样\nQ = {q0,q1,q2,q3}I = {q0}F = {q3}Sigma = {a,b,c}Delta(q0,a) = q1Delta(q0,a) = q2Delta(q1,b) = q1Delta(q1,b) = q3Delta(q1,c) = q2Delta(q2,a) = q3Delta(q3,b) = q2\n\n输出这样\nQ = {{q0},{q1,q2},{q3},{q1,q3},{q2},{q1,q3,q2}}Init = {q0}F = {{q3},{q1,q3},{q1,q3,q2}}Sigma = {a,b,c}Delta({q0},a)={q1,q2}Delta({q1,q2},a)={q3}Delta({q1,q2},b)={q1,q3}Delta({q1,q2},c)={q2}Delta({q3},b)={q2}Delta({q1,q3},b)={q1,q3,q2}Delta({q1,q3},c)={q2}Delta({q2},a)={q3}Delta({q1,q3,q2},a)={q3}Delta({q1,q3,q2},b)={q1,q3,q2}Delta({q1,q3,q2},c)={q2}\n\n这个输入输出的格式还是抄的C++的那个。\n处理起来确实麻烦。但好看还是挺好看的。有点爽。\n咋实现的捏验收完了直接丢代码得了。懒得写啥心路历程了。\n加了注释总共两百来行，挺弱智的。懒得分析了。\n就当开了个坑，看以后记不记得放代码了。\n过几天再开个坑。go写一写堆优化的Dijkstra。\n","tags":["Go"]},{"title":"深夜emo_1","url":"/2022/04/12/night._1/","content":"以后干活到一点之后就打个深夜tag放点emo屁。\n这算是第一次。\n赶课设的需求代码赶了两个多小时。差不太多。\n前两个小时脑子有病拿个手机一边水群一边赶，屁效率没有完事了还被群嘲。\n确实沾点真傻逼。\n剩下不到一个小时打算rush一下，然后翻一下文档发现需求看错了。\n要求传结构体，我弱智一样写了个string。\n更傻逼了。\n结果算了算传结构体还得写个比较函数，不然排序直接寄。\n结果搜了搜你妈go又没有加权的比较函数，我还得自己写。\n也可能是我自己傻逼没搜到。总之都挺傻逼的。\n一个结构体里六个元素降序比较，嗯写了个暴力比较。我看那一串if和else想着这下傻逼到家了。\n复制粘贴复制粘贴滚了几遍总算把需求弄完了。弄完了不想看，估计出错的bug能垒一座山。\n反正交了。错不错不想管了。错了到时候再改就完事了。\n摆就完事了。\n想了想还真是。\n真傻逼啊。\n反正早八马原等于没课，找点小说再混两小时等昏迷。\n迟早进坟。\n","tags":["脑子有病"]},{"title":"Go搭一个弱智本地服务器","url":"/2022/04/10/GO_3/","content":"数据结构课设用的。前后端交互后端不给搭个本地服务器确实没法跑。\n没研究http协议，随便看了下go开发文档里给的http包就开抄了。\n反正只是课设用。写的多弱智都行。\n当然弱智的估计只有我，有的大爹自己把通讯模块写了的也有，不能一概而论。\n看看大爹：\n\n随便讲讲代码咋写的。不分析函数了。我自己都看不懂传的参数是在干啥。\n首先把首先先把包导入了。不然写个p。\nimport (\"net/http\")\n我们组做的web，和前端交互那也就是和http跑协议，所以直接调的http包。\n那就开写被先写个StartServer。\n名字叫启动服务主要是有点仪式感。不然代码就写的跟怨妇一样了。\nfunc StartServer() {\thttp.HandleFunc(\"/api/\", APIHandler)\thttp.Handle(\"/\", http.FileServer(http.Dir(\"front\")))\tgo ServerTest()\terr := http.ListenAndServe(\":5000\", nil)\tif err != nil {\t\tLog(fmt.Sprintf(\"Web 服务启动失败，请检查您的防火墙设置并确保 5000 端口没有被占用\", port))\t\tos.Exit(1)\t}}\n\nmd的这个go代码做的标识是真敷衍。好丑。\n第二行里的传的第一个参数可以改。爱咋改咋改，反正和APIHandler里的pattern对的上就行。不是很重要。\n第三行的第一个参数就别动了，弱智服务器犯不上改那个。第二个参数是开了前端文件夹传进去了。front是前端文件夹名。\n第四行跑了个服务器测试，晚点贴代码。测不测都行。图个好看。\n第五行监听端口，这里监听的是 5000 。爱改其他的也行。反正都能用。\n六七八九就是个错误检测了。爱检测就检测，不检测也没人说你。\n反正就这几行，大致框架就搭起来了。至于具体交互的就是APIHandler里的事了。\nAPIHandler看看交互咋写被。\nfunc APIHandler(w http.ResponseWriter, req *http.Request) {\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\tw.Header().Set(\"content-type\", \"application/json\")\tswitch req.URL.Path {\tcase \"/api/isServing\": //判断web服务是否成功启动\t\tw.Write([]byte(\"true\"))        ....    ....}\n\n大致是这样。\n第二行和第三行改了头。不改行不行捏，我觉得行，你可以试试。\n第六行是api名字，前端就指着这个拿东西了。\n不从前端提数据那应该也就这样了。一直writewrite就完事了。挺直接的。\n提数据的话就加一行.\nquery := req.URL.Query()\n\n然后拿query给的函数开提数据，query.Get就完事了。\n整个测试函数被拿现成的东西就行，都写上面了。\nfunc ServerTest() {\tfor {\t\tres, err := http.Get(\"http://localhost:5000/api/isServing\")\t\tif err == nil {\t\t\tdefer res.Body.Close()\t\t\tbody, _ := ioutil.ReadAll(res.Body)\t\t\tif string(body) == \"true\" {\t\t\t\tfmt.Println(\"Web 服务启动成功，请访问 http://localhost:5000 进入系统\")\t\t\t\tbreak\t\t\t}\t\t}\t}}\n\n相当于试试 http://localhost:5000/api/isServing 这个api能不能使。能使就告诉你能使。\n用了个defer，害挺高级。不用defer自己最后关也行。 \n前端咋提数据那得看你用啥框架。jQuery和axios不能一概而论。手搭ajax也行。\n反正前端也不是我写的，我管不到。\n看看前端大爹：\n前端爹\n没了","tags":["Go"]},{"title":"Go的基础语法","url":"/2022/04/08/GO_1/","content":"不全，看文档的时候顺便写的笔记。\ninterface开始就没记了。后面go语言网络编程语法更是不知所云。\n要不是项目有现成的代码抄我没准真的把文档看完。\n感谢前人大爹了属于是。\nGoGo基础变量定义\n完整声明\n\nvar variableName type\nvar vname1,vname2,vname3 type\nvar variableName type = value\nvar vname1,vname2,vname3 type = v1,v2,v3\n\n\n忽略类型\n\nvar vname1,vname2,vname3 = v1,v2,v3\n\n\n极简。只能用在函数内部\n\nvname1,vname2,vname3 := v1,v2,v3\n\n\n声明了变量未使用会报错\n\n\n变量类型\n支持复数。\n\ncomplex128\ncomplex64\n形式为RE+IMi\n\n\n支持Raw字符串，即字符串在代码中的形式就是打印的形式，没有字符转义，换行也会原样输出。形式是用``框起来\n\n错误类型。package的包里有一个errors。看那个包。\n\n数组\n\nvar arr [n]type\na := [n]type{….}\n\n\n切片slice\n\nvar fslice []type\n\nslice := []byte {…..}\n\nslice可以通过从已有数组里切割出来\n\nslice := arr[2:5]\n\n\nslice是引用类型。如果改变了slice里的值，那么引用的位置的值也会改变。\n\n就是说slice切了数组出来，改了slice，之前的数组里的元素也会变\n\n\nslice的几个内置函数\n\nlen。获取slice的长度\ncap。获取slice的最大容量\nappend。往slice里追加一个或者多个元素。然后返回一个类型一样的slice\n如果长度已经抵达了最大容量，append会申请新的内存-\n\n\n\n\nGo的1.2版本后可以指定slice的容量。这样可以避免在切割后，访问到了不想令其访问的原数组部分。\n\nslice := arr[2:4:7]\n其中7就是容量\n\n\n\n\n\n\nmap。字典类型。特点是不一定要用int类型来做key。可以是其他类型。也就是哈希表。\n\n格式为map[keyType]valueType\n删除map中的元素\ndelete(mapname,”vname”)\n删除名为vname的元素\n\n\n\n\n\n\nmake和new\n\n内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：\n内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。\n\n\n\n流程和函数流程语句\nif不需要括号了\nif x &gt; 10 {    fmt.Println(\"x is greater than 10\")} else {    fmt.Println(\"x is less than 10\")}\n\n\n同时if可以在条件判断语句里声明一个变量。同时这个变量只在条件逻辑块内起作用\n// 计算获取值x,然后根据x返回的大小，判断是否大于10。if x := computedValue(); x &gt; 10 {    fmt.Println(\"x is greater than 10\")} else {    fmt.Println(\"x is less than 10\")}//这个地方如果这样调用就编译出错了，因为x是条件里面的变量fmt.Println(x)\n\n\nfor也不需要括号了\npackage mainimport \"fmt\"func main(){    sum := 0;    for index:=0; index &lt; 10 ; index++ {        sum += index    }    fmt.Println(\"sum is equal to \", sum)}// 输出：sum is equal to 45\n\n\ngo里的循环可以省略到只剩条件语句。也就是直接变成了while\nsum := 1for sum &lt; 1000 {    sum += sum}\n\n\nrange函数\n\n针对于slice和map。用来读取slice和map的数据。\n\n返回值两个。元素的序号和元素的内容\nfor k,v:=range map {    fmt.Println(\"map's key:\",k)    fmt.Println(\"map's val:\",v)}\n\n\n说实话我也不知道这个啥原理。很牛逼\n\n\n如果不需要序号元素的话可以省略\nfor _, v := range map{    fmt.Println(\"map's val:\", v)}\n\n\n\n\nswitch。\n\ngo的switch自带break。如果要强制往下执行就在每句句尾加一个fallthrough\n\n\n\n函数\n可以返回多个返回值\npackage mainimport \"fmt\"//返回 A+B 和 A*Bfunc SumAndProduct(A, B int) (int, int) {    return A+B, A*B}func main() {    x := 3    y := 4    xPLUSy, xTIMESy := SumAndProduct(x, y)    fmt.Printf(\"%d + %d = %d\\n\", x, y, xPLUSy)    fmt.Printf(\"%d * %d = %d\\n\", x, y, xTIMESy)}\ndefer语句\n\nGo语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。\n\n\n代码如下\n\n\n\nfunc ReadWrite() bool {    file.Open(\"file\")    defer file.Close()    if failureX {        return false    }    if failureY {        return false    }    return true}\n\n\n如果有很多调用defer，那么defer是采用后进先出模式，所以如下代码会输出4 3 2 1 0\n\nfor i := 0; i &lt; 5; i++ {    defer fmt.Printf(\"%d \", i)}\n\n\n可以用ype来定义函数的类型\n\n","tags":["Go"]},{"title":"SQL的一点语法","url":"/2022/04/08/SQL/","content":"sql看了一半发现课设用不上了\n有点死心\n不过还是得说json真好使。\n大三估计得正式学数据库，这个就当不知所云的呓语。\nSQL语法DLL 数据定义语言创建数据库\ncreate database .创建数据库\nshow database. 显示已有数据库\ncreate database if not exists . 不存在这个名字的数据库就创建\ncreate database  character set uft8. 创建数据库的同时指定字符集\nshow create database . 显示指定数据库的创建指令\n\n修改数据库\nalter database  character set gbk.更改对应数据库的字符集\n\n删除数据库\ndrop database . 删除数据库\n\n切换数据库\nuse . 切换数据库\n\n创建数据表\ncreate (row_1 char(8) not null  unique,row_2 varchar,row_3 int,….,row_n char)   。row_i可以是对应列的名字。 \nchar是不可变字符组。char后补(num)指定这一列的最长长度，不够这个长度会补空格。\nvarchar是可变字符组。varchar后补(num)指定这一列的最长长度，不够这个长度不会补空格。\nnot null后缀用以确保该列信息必须填写。不持有这个后缀的信息列，不填充信息则会默认为null\nunique后缀用以确保该列中信息唯一，即该列中不能填写相同的信息。\n\n\n\n查询数据表\nshow tables 查询数据表列表奥\ndesc  。查看特定表的结构\n\n删除数据表\ndrop table 。删除数据表\n\n修改数据表\nalter table  rename to .修改表名\nalter table  character set utf8.修改表的字符集\nalter table  add  。对表添加一种新的字段\nalter table  change  .。修改表内的一个字段名和类型\nalter table  modify  .只修改字段类型\n\nSQL数据类型数值类型\ntinyint    -128~127\nsmallint    -32768~32767\nmediumint 3byte\nint 4byte\nbigint  8byte\nfloat 单精度\ndouble 双精度\ndecimal(n,m) 双精度。括号内指定数字位数和小数点后位数。即最多有m位，n个小数点后位数\n\n字符类型\nchar 0~255 定长\nvarchar 0~65535 可变长度\ntinybolb 0~255 存储二进制字符串。也就是说可以通过二进制字符串转换来存图片之类的。/\nbolb 0~25535 存储二进制字符串\nmediumbolb 0~16677215 存储二进制字符串\nlongblob 0~4294967295 存储二进制字符串\ntinytext 0~255 文本数据\ntext 0~65535 文本数据\nmediumtext 文本数据\nlongtext 文本数据\n\n日期类型\ndate 。只能存放年月日。没有时分秒。格式 2021-09-13\ntime 。 11：11：23。只有时分秒\nyear。2021.只有年份\ndate time。 2021-09-13 11：12：13.存放年月日时分秒\ntimestamp。20210913 111213.年月日时分秒。但中间没有分隔。时间戳\n\n字段约束\n非空约束。限制此列的值必须提供。\n\n唯一约束。此列的值不能重复\n\n主键约束。表中记录的唯一标识。可以是一个列，也可以是多个列的组合\n\n创建表的时候定义主键。 create table （classid varchar(15) primary key）或者create table （classid varchar(15) ,primary key(classid)）\n\n删除数据表主键约束。alter table  drop primary key\n\n主键自动增长。create table (classid int primary key auto_increment )。自动增长只保证唯一性不保证连续性。\n\n联合主键。create table (classid varchar(15),stuid varchar(15),primary key(classid,stuid))\n\n\n\n外键约束\n\n\nDML 数据操作语言添加数据\ninsert into () values() 。tbname后面的括号里用来指定赋值的字段，values里用来赋值。\n\n删除数据\n从数据表中删除满足需求的数据。delete from  where .\nconditions里用来指定特定数据。通过对字段的判断来进行条件的选择。如classid=’10010‘或者stu_age&gt;20\n\n\n\n修改数据\nupdate  set =’…‘  where classid=’…’\n\nDQL 数据查询语言从数据表中提取满足要求的记录\n\nselect ,, from   [where conditions] 。sname指定要要查询指定数据的哪些字段。tbname指定表。如果要显示查询到的所有字段，就用*来替代字段名的列表。\n\nwhere子句删除修改查询语句后都可以加入where子句，用于筛选满足特定条件的数据进行删除修改查询。\n\n条件。\n\n=        等于，精确匹配。\n！=    不等于\n&lt;&gt;  小于或者大于，即不等于\n大于小于，大于等于，小于等于和其他语言的语法一致\nbetwe and。相当于是区间查询。select * from class class_time between 18 and 20\n\n\n多条件查询。通过多个条件来筛选数据\n\nand 相当于是&amp;&amp;。where  and \nor 相当于是||。where  or \nnot  用在between and前，表示区间反转。select * from class class_time not between 18 and 20\n\n\n\nLIKE子句模糊查询\n\nselect * from  where   like \n如：select * from stus where stu_name  like ‘%o%’           可以把名字中所有含有o的记录显示出来\n在like关键字的表达式中，%表示任意多的字符，_表示任意一个字符\n\n\n\n查询结果处理\n计算列和别名。可以对数据表中查询的列，进行一定计算再显示出来。别名是在显示的时候对字段使用其他的名字\n\n如：select  as ,2021-, from   [where conditions]   那么第二行给出的数据会是2021-对应栏数值得到的数据。同时第一栏的数据的字段名将用sname4来显示\n\n\n消除重复行。在查询结果中将数据重复的数据删除。select distinct  from \n\n\n查询结果排序——BY排序\nselect  from  where  order by  ,,…., [asc||desc]\n\n代表根据sname2,sname3…,snamen的内容对查询到的信息进行排序显示，其中越在前的优先级越高。\n\n默认是升序排列。后缀的asc代表升序，desc代表降序。\n\n\n\n\n聚合函数聚合函数是指SQL提供的对数据表中的某些列进行运算的函数\n\ncount()    统计函数。统计满足条件的指定字段数的记录数，如：\n\n统计学生表中的学生人数\n\nselect count(stu_num) from stus \n\n\n统计学生表中的男生人数\n\nselect count(stu_num) form stus where stu_gender=’男’\n\n\n\n\nmax()。找出查询信息中的最大值记录\n\nmin()。最小值\n\nsum()。计算和\n\navg()。求平均值。\n\n\n日期函数\n对日期类型添加数据，可以采用字符串赋值，但字符串的形式必须是yyyy-MM-dd hh:mm:ss。用当前日期插入到数据列中，用函数now()或者sysdate()\n获取当前系统时间可以用select now()或者select sysdate()\n\n字符串函数\nconcat(sname1,sname2,….) 。把指定的字符串拼接起来。\n\n如:select concat(stu_name,’-‘,stu_age) from stus\n\n\nupper(sname) 。将对应的字符串都改成大写\n\nlower(sname)。将指定字符串都改成小写。\n\nsubstring(sname,n,m)。截取字符串，从对应的字符串的第n位往后截取m位来显示。如果n写start就指代从第一位开始\n\n\n分组查询\n分组就是对数据表中指定的列进行分组\n\n\nselect by\nselect … from  group by  [having ]   \n根据sname1对tbname进行分组。其中…表示要求选择显示的字段。如果…替换成*，则只会显示每个分组的第一个记录。\nhaving语句内表示条件，是对分组后的结果进行指定条件的筛查。\n\n\n\n分页查询\n数据表中的记录比较多，一次性查询过多，则可以分页展示\n\n\nlimit n,m 从第n条开始显示，共显示m条数据。limit语句放在语句末尾。也就是在where，order之类语句之后。\n如:select stu_name form stus limit 0,3\n\n\n\n关联关系一对一\n主键关联。不同表中主键相同即相关联。\n唯一外键。任意一张表中添加一个外键字段来与另外一个表关联。\n\n一对多\n在多的一端设置外键，然后与一的部分进行关联。\n\n多对多\n额外创建一个关系表。用来维护多对多的关联。\n\n关系表中的字段中有多个外键。分别用来指代不同的多。\n\n\n外键约束","tags":["课外"]},{"title":"vscode里Go的分文件","url":"/2022/04/03/GO_2/","content":"vscode里走c和c++的分文件倒是方便，只要引入和头别写的太弱智基本都能分。\ngo不太行，不知道是我的问题还是go的遗留问题。\n主要是go分文件这一块，只要是一个文件夹里的，开头写个\npackage main\n\n那放在vscode里头都算你是一个项目的了。当然你直接run还是不太行，但起码你写代码的时候该有的提示都会有，也不至于给你报一万个波浪线错误，一天到晚undefined。\n当然有时候放一个文件夹里，补了个package的开头，还是报一大堆undefined的事情也不新鲜，我的经验是往vscode命令行打个\ngo export GO111MODULE=auto  \n\n如果还不行，回你的项目文件夹跑一个\ngo init mod &lt;filename&gt;\n\n那应该就行了。反正我这就行了。\n你要是不信我去csdn上搜上一阵，那我估计你也搜不出啥好用的。csdn上的最高赞给的方法是丢到GOPATH里，问题是GOPATH已经不是这个版本的东西。go 1.1之后好像就开始用go mod做版本管理了。把这个讲的比较清楚那估计得回头看go的开发文档了。\n好了，写代码不报错那分文件也就成功了一半了。\n剩下的就是咋跑代码了。毕竟用vscode直接跑大概率是跑不起来了。这一点跟c和c++又不太一样。\n反正我是直接\ngo run .\\\n意思是一个文件夹下的全部编译然后开跑。\n比较需要注意的是，vscode这必须得直接打开放代码的文件夹，毕竟vscode的命令行默认是从根目录开始的，也就是你打开的文件夹。\n总的来说就是没有一点依据的个人经验。我也不知道我在说啥。\n","tags":["Go"]},{"title":"书评 | 《从红月开始》","url":"/2022/04/02/redmoon/","content":"开个坑。以后写。\n","tags":["杂谈"]},{"title":"计网物理层","url":"/2022/04/01/jiwang_2/","content":"上课教的这和考研内容差的是真多啊。\n主要范围是按照ppt给的范围来。参考的大爹的笔记不是特别全。\n描述是教材的，图是偷的，总之没我自己写的。\n基础概念\nChannel：信道\nBit Rate：数据率\nBaud：波特\nPropagation Speed：传播速度\nBandwidth：带宽\nChannel Capacity：信道容量。信道的最大数据率\nThroughput：吞吐量\nBER（Bit Error Rate）：误码率。传送错的位数总位数 \nDelay：时延\n时延的组成：传播时延，发送时延，处理时延，排队时延\nNodal processing delay(处理时延)\n检查比特错误\n决定输出链路\n\n\nQueueing dealy（排队时延）\n输出链路上等待传输的时间\n取决于路由器的拥塞程度\n\n\nTransmission delay(转发时延)\n链路带宽\n包的长度\n发送时延\n\n\nPropagation delay（传播时延）\nd = length of physical link\ns = propagation speed in medium\npropagation delay = d/s\n\n\n\n\n\n\n补个带宽爹的两个意义：\n\n\n通信方式：\n\nSimplex\nHalf-duplex\nFull-duplex\n\n\nParallel。并行通信\n\n\n\n\nSerial。串行通信\n\n\n\n\n同步串行传输\n\n以时钟信号线对传输的数据线上的信号进行比特分布\n以数据块（帧或分组）为单位传输\n\n\n异步串行传输\n\n独立时钟，无需同步\n以字符为单位进行传输\n发送两个字符之间的间隔是任意的\n接收方依靠字符中的起始位和停止位来同步\n\n\n\n2.1 数据通信的理论基础\nFourier Analysis：\n\n书上就这一页ppt。能记住公式都算超出纲要了\n\n\n\n\n\n2.1.2 带宽有限的信号这一块讲的有点莫名奇妙。没搞明白这块能怎么考。\nppt上稀碎的。\n\n\n在传输过程中振幅不会明显减弱的频率的部分的宽度就称为带宽。\nbaseband：基带。一般指的是从0到某个最大频率的信号称为基带信号。\npassband：通带。将被搬移并占用某个更大频率范围的信号称为通带。\n书上通带的解释莫名其妙。重新给个：通带,就是有效带宽，指两个截止频率之间的频率范围\n\n\n\n后面还提了带宽的两个意义。前面写了，这里不赘述。\n2.1.3 信道的最大数据率爹中爹要来了。\n奈奎斯特定理\nIf a signal has been run through a low-pass filter of bandwidth H,  the signal can be completely reconstructed by making 2H samples per second有限带宽的无噪声信道的最大数据传输率\n\n\n\n注意：这里的2B指的是采样频率是2B。也就是说数据速率是直接受制于采样频率的。而在采样频率低于2B时，采样频率可以直接和Baud一比一换算。如题：\n当然这题目描述有点问题。但意思是这个意思，到了就行。\n\n\n\n给个正常的题目样例。偷的。\n香农定理噪声信道的最大传输速率\n\n\n给个例题。也是偷的。这道题没给电平级数，所以不考虑奈奎斯特。\n\n注意：若一道题里既给了信噪比又给了电平级数。则奈奎斯特和香农都要计算，然后取较小的值。电平级数较小时奈奎斯特得到的结果一般都比香农结果要小，因此不可妄取香农。\n\n2.2 引导性传输介质讲这个的时候我打老头环去了，也不知道哪里是重点哪里不是，所以找的别人笔记抄的。\n老头环是真好玩啊。\n2.2.1 Magnetic Media磁介质。\n高带宽高延迟。\n很贵。\n2.2.2 Twister Pair双绞线。\n带宽特性优良，延迟特性很差。\n最常用的传输媒体，可用于传送模拟或数字信号。\n两根线绞在一起可以构成一个天线，不同电线产生的干扰会相互抵消，显著降低电线的辐射。\n信号通常以两根电线的电压差来承载，这样对外部噪声有更好的免疫力。\n到6类为止，都是非屏蔽双绞线（UTP）\n7类双绞线在每对，整个线缆外加一个屏蔽层。\n2.2.3 Coaxial Cable同轴电缆。\nIt can span longer distances at higher speeds\nHigh bandwidth(1GHz)\nExcellent noise immunity\n2.2.4 Power Line电力线\nboth inside the home as a LAN and outside the home for broadband Internet access\ndesigned to distribute power signals\n2.2.5 Fiber Cables光纤。\n根据中心光纤的直径，分为多模、单模\n多模以不同的角度来回反射着前进，单模直径只有几光波，几乎沿直线传输\nHigh bandwidthLightweightSecurity\n书上一大堆，ppt上就两页。我折中一下多加了几句意思意思。\n2.3 Wireless Tranmission老头环真好玩。\n2.3.1 电磁频谱电磁频谱的图不放了，看不懂记不住。\n传输频带：\n\nUsing narrow frequency band。大部分用的就是窄波频段\nSpread Spectrum (bluetooth, wlan, cdma)。少数用较宽频段。\nFHSS：跳频扩频。发射器以每秒几百次的速率从一个频率跳到另一个频率\nDSSS：直接序列扩频。这种方法使用了一个码片序列，并且将数据信号展开到一个很宽的频段上。\nUWB：超宽带通信。UWB发送一系列快速脉冲，这些脉冲随着通信信息而不断变化自己的位置。这种位置的快速变换导致信号被稀疏分布在一个很宽的频带上。\n\n\n\n2.3.2 Radio Tranmission\n\n无线电传输是像个气球一样沿着各个方向传播的，所以不用刻意对齐(下面那个微波传输就得对齐)\n无线电频率RF（Radio Frequency）\n路径损耗 不同于引导性介质上的信号衰减是以y=b-kx的大致形式衰减，无线电波随着距离增加，信号能量衰减的速度以距离的-2次幂下降(相当于下降的斜率在不断减小)，这意味着无线电信号可以传播很长的距离。\n\n2.3.3 Microwave Transmission微波传输。\n波的传播几乎是直线的，发射和接收天线必须准确对齐\nDistance between repeaters: 80km每隔一段距离就需要一个中继器。\n延迟抵达的微波与直接传输的微波可能不同相，因而信号会相互抵消。这种传播效果称为多径衰落(multipath fading)\nMultipath fading(多径衰落) is often a serious problem (取决于天气和频率)\n电磁频谱政策不提了。\n2.3.4 Infrared Transmission红外传输。\nwidely used for short-range communication\n方向性，便宜\ndo not pass through solid objects\n2.3.5 Lightwave Transmission光通信。不受控的光信号。\n瞄准很难。\n激光束不能穿透雨或者浓雾。\n2.4 Communication Satellites这一节都不明所以，非常突兀，前后无关联。\n我觉得不会考。\n2.5 Digital modulation and multiplexing数字调制和多路复用。\n\n比特与代表它们的信号之间的转换过程称为数字调制( digital modulation)。\n信道通常被多个信号共享。毕竟，用单根线缆传送几个信号比为每个信号铺设一根线缆要便利得多。这种信道的共享形式称为多路复用技术( multiplexing)\n\n2.5.1 Baseband Transmission基带传输。\n中文版的图是真傻逼。\n\n\n带宽效率 bandwidth efficiency\nNRZ need a bandwidth of at least B/2 Hz when the bit rate is B bits/sec（见奈奎斯特）  \nbit rate=baud rate * the number of bits per symbol\n就是比特率和波特率的关系\n\n\n信号的级别数不一定是2的幂次方。\n\n\n时钟恢复 clock recovery\n说白了就是接收信号接收信号的时候要对时。\nManchester / NRZI。曼彻斯特和不归零逆转可以在信号里自带对时功能。其中NRZI是在NRZ基础上的改善。\n4B/5B编码不会有三个连续的0。4B/5B是用来解决信号里一长串的0会出现的问题。不细说，我觉得以后会讲。\n这几种编码ppt里就是提了一嘴。第四章应该会细讲。\n\n\n\n\n平衡信号。balanced signals。\n短时间内正电压和负电压一样多的信号称为平衡信号。\n可以通过使用两个电压级别来表示逻辑1。是构造平衡信号的简单方法。即双极编码。\n8B/10B。8位被分成一组5位映射到6位，一组3位映射到4位。通过编码映射做到平衡信号。\n\n\n\n2.5.2 Passband Transmission通带传输。通过调节载波信号的幅值、相位或频率来运载比特的方案。信号占据了以载波信号频率为中心的一段频带。是无线和光纤信道最常使用的调制方法。只能在给定的频带中传输信号。\n\n\n对于这几种要认得出来\n\n辐移（ASK频移（FSK相移（PSK\n\n二进制相移键控。BPSK。最简单的相移键控。只有偏移0度和180度两种。\n正交相移键控。QPSK。四种偏移，45，135，225，315度。每个符号可以传输2个比特信息。\n\n\n这种图叫星座图（constellation diagram\nQAM指的是正交调幅，同时调制了振幅和相位。\n其中若有个组合，则表示每个符号可以传输个比特。\n2.5.3 频分复用 FDM\n图中展示了采用FDM技术复用的三个语音及电话信道。滤波器将每个语音级信道限制成大约为3100Hz的可用宽带。当多个信道被复用在一起时，为每个信道分配4000Hz带宽。比语音通信所需多出来的那部分频带称为保护带（guard band），使得信道之间完全隔离。\n\n两个信道中间夹一个保护带。\n\n2.5.6 时分复用 TDM每个输入流的比特从一个固定的时间槽(time slot)取出并输出到混合流。该混合流以各个流速率的总和速度发送。这种工作方式要求输入流在时间上必须同步。类似于频率保护带，为了适应时钟的微小变化可能要增加保护时间(guard time)间隔。\n\n2.5.5 码分复用 CDM这个稍微复杂点。不过意思还是那个意思。\nppt上就一页。不知道写ppt的人怎么想的。\n\n码分复用(CDM, Code Division Multiplexing)是扩展频谱(spread spectrum)通信的一种形式，它把一个窄带信号扩展到一个很宽的频带上。这种方法更能容忍干扰，而且允许来自不同用户的多个信号共享相同的频带。\n\n码分多址（CDMA）：在CDMA中，每个比特时间被再细分成m个更短的时间间隔，这更短的时间间隔就称为码片(chip)。每个站被分配得到唯一的m位码，称为码片序列(chip sequence)。\n\n我们假设用符号S表示站S的m码片向量，用表示它的反码。所有的码片序列都两两正交(orthogonal)，这意味着任何两个不同的码片序列S和T的归一化内积(写为S·T)为0。我们知道，利用Walsh码(Walsh code)可以产生这样的正交码片序列。\n\n任何码片序列和自身的归一化内积一定是1。\n\n\n为了恢复出某个特定站的比特流，接收方必须预先知道这个站的码片序列。只要计算收到的码片序列与该站的码片序列的归一化内积，就可以恢复出该站的比特流。如果收到的码片序列为S，接收方正在监听的那个站的码片序列为C，那么，它只要计算两者的归一化内积，即S·C。\n\n\n给个例子说明这玩意儿咋用的。 \n\n图里都是计算对C站的接收。\n\n波分多路复用 WDM \n2.6 The Public Switched Telephone Network \n  \n 总而言之，电话系统由以下三个主要部分组成：\n\n本地回路(进入家庭和公司的模拟双绞线)。Local loops\n中继线(连接交换局的数字光纤)  Trunks\n交换局(电话呼叫在这里从一条中继线被接入到另一条中继线)Switching offices\n\n2.6.3  The Local LoopModems调制解调器。\n调制解调器是调制器（modulator）和解调器（demodulator）的缩写。\n\n\n调制解调器使用多种调制技术的组合让每个波特可以传输多个比特。如QPSK和QAM。\n调制解调器采样频率是2400times/sec。因此提升传输速率依靠提高每波特携带的比特数。\nV.32: 2400 baud * (5-1) bits = 9.6Kbps\nV.32bis: 2400 baud * (7-1) bits = 14.4Kbps\nV.34: 2400 baud * 12 bits = 28.8Kbps\nV.34bis: 2400 baud * 14 bits = 33.6Kbps\n\n\nV.90(56kbps)\n\nADSL前置有个xDSL服务。懒得看。就不放了。\n非对称数字用户线(ADSL, Asymmetric DSL)\n\n\n为了满足技术目标，本地回路上的1.1MHz频谱被分成256条独立的信道，每条信道宽4312.5Hz。\n\n信道0用于简单老式电话服务(POTS, Plain Old TelephoneService)。信道1~5空闲，目的是防止语音信号与数据信号相互干扰。在剩下的250条信道中，一条用于上行流控制， 另一条用于下行流控制，其他的信道全部用于用户数据。\n\n也就是说是248条用于用户数据\n\n\n大多数提供商倾向于将80%~90%的带宽分配给下行信道，因为大多数用户的下载数据量超过上载数据量。这种选择正好暗示了ADSL中的第一个字母A(非对称)。一种常见的分法是32条信道用于上行数据流，其余的用于下行数据流。\n\n在每条信道内使用了QAM调制方案，速率约为4000baud。最高可以达到每buad里15bit\n\n\n光纤到户 FttH\n2.6.4 Trunks and Multiplexing中继器和多路复用\n\nPCM(脉冲编码调制：在端局，把模拟信号数字化的工作由一个称为编码解码器(codec, coder-decoder)的设备完成。编码解码器每秒采集8000个样值(125微秒样值)，根据尼奎斯特定理，这个采样率足以捕捉一切来自4kHz电话信道带宽上的信息。若采样率较低，信息就会被丢失若采样率较高，也得不到更多的信息。每个信号的样值幅度被量化成一个8比特的数字。\n\n这种技术就是脉冲编码调制(PCM, Pulse Code Modulation)，它构成了现代电话系统的核心。因此，几乎电话系统内的所有时间间隔均为125微秒的倍数。也正是因为这个原因，语音级电话呼叫的标准化未压缩数据率是每125微秒8比特，或64kbps\n\nTDM时分多路复用\nT1载波(T1 carrier)\nT1载波包含24条被复用在一起的语音信道，每个信道依次将8比特的样值插入到输出流中\n每帧包含24×8=192个比特，再加上额外一个比特用于控制，因而每125微秒产生193个比特。这样得到的数据传输率为1.544Mbps，其中8kbps用于信令控制。第193个比特用于帧同步和信令。\nThe T1 carrier (1.544 Mbps).E1 2.048Mbps\nT1复用到高级载波\n\n\n2.6.5 Swicthing没啥说的。老一套。下面两道题吃透了基本这个知识点就吃透了。\n\n我字写的好丑（赞叹\n","tags":["计网"]},{"title":"朽骨朝佛","url":"/2022/01/25/past_1/","content":"\r\n  c1b4b0d698ffb82b90d6029abafc5e27d298839133a4c7646bdc3a39e5eaf1bade5229873e01340d7ac054ff5fd0db0119f0d31e5922bfc357996e48ae1095deaf1c25a4c3f3734bbe86dd379c30f4d3\r\n  \r\n    \r\n      \r\n      \r\n        空空念想\r\n      \r\n    \r\n  \r\n\r\n","tags":["杂谈"]},{"title":"进行一个毛概的摆","url":"/2022/01/16/godknow2/","content":"","tags":["课程"]},{"title":"进行一个计组的烂","url":"/2022/01/16/jizu/","content":"懒得看书，基本直接照抄ppt。但这不是说ppt做的多好，这ppt糙的不行,很多细节还有问题。\n第一章 计算机概述1.1 计算机的分类和应用\n通用计算机分类 如图：  \n面向应用的分类\n通用计算机。具有计算机的标准形态，安装不同的应用软件，以相似的外观呈现并应用在各行各业。例如你的pc\n专用计算机/嵌入式计算机。安装或嵌入到交通工具、仪器仪表、控制系统、通信设备和家电产品里的模块化计算机。\n\n\n计算机的应用领域\n科学计算\n信息处理\n实时控制\n人工智能\n计算机辅助设计\n娱乐游戏\n\n\n\n1.2 计算机的发展简史1.2.1 计算机的五代变化\n按时间顺序排\n数据处理机\n工业控制机\n小型计算机\n微型计算机\n单片计算机\n\n\n\n1.2.2和1.2.3跳了，没啥东西。\n1.2.4 计算机的性能指标书上直接给的是八个指标。ppt上还加了个容量，反正分开讲。\n\n容量：  这里取地址寄存器位数为N，数据寄存器位数为M，则  总容量存储单元个数存储字长存储单元个数存储字长\n\n机器字长：指处理机运算器中一次能够完成的二进制数运算的位数。（一般等于内部寄存器的位数）\n主频/时钟周期：CPU的工作节拍受到主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率称为CPU的主频。时钟频率主频时钟周期\nCPI：每条指令执行所需要的时钟周期数，或每条指令执行所需的平均时钟周期数。指令耗时时钟周期\n。\nMIPS：每秒百万指令数 指令总数程序执行时间\nMFLOPS：每秒百万次浮点操作次数程序中浮点运算次数程序执行时间\nGFLOPS：每秒十亿次浮点操作次数程序中浮点运算次数程序执行时间\nTFLOPS：每秒万亿次浮点操作次数程序中浮点运算次数程序执行时间\n\n\n总线宽度：数据总线一次所能并行传送信息的位数\n存储器带宽：单位时间内从存储器读出的字节数，一般用字节数/秒表示。 \n吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S） \n响应时间：指从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间\n包括CPU时间与等待时间\n\n\n利用率：在给定的时间间隔内系统被实际使用的时间所占的比率，用百分比表示\n\n1.3 计算机的硬件照抄ppt，书上的细节懒得写了，如果考试要考那复习的时候再加上。\n\n计算机由运算器、控制器、存储器、输入设备、输出设备五大部件组成\n存储器：存放程序和数据\n控制器：根据取得的指令向其他部件发出控制信号，完成指令规定操作\n运算器：完成算术和逻辑运算操作，也称为数据通路\n输入/输出设备：完成人与计算机的相互通信\n\n\n在机器内部，指令和数据均已二进制码表示\n指令由操作码和地址码组成\n\n\n机器以运算器为中心，数据传送都经过运算器\n采用存储程序的方式，编制好的程序和数据存放在同一储存其中，计算机自动完成逐条取出和执行指令的操作。故称为存储程序计算机\n\n1.4 计算机的软件\n计算机软件分类\n系统程序：管理整个系统\n应用程序：完成特定任务，使用系统软件提供的资源接口。\n\n\n计算机软件层剖析  计算机系统计算机结构处理器机器语言汇编语言高级语言\n\n1.5 计算机的层次结构1.5.1\n\n\n\n1.5.2 软件与硬件的逻辑等价性\n硬件 – 能实现高速的算术逻辑运算功能，但难以实现较复杂的功能或实现的代价太高\n软件 – 易于实现各种复杂的算术逻辑运算功能，但是频繁的访存操作制约了处理速度\n从理论上讲，任何软件算法可以用软件实现，也可以用硬件实现，即：软件和硬件在逻辑上等价\n\n看的出来这老师很赶时间，上面这一大堆一次课就讲完了。\n第二章 运算方法和运算器这一章东西就多了。\n2.1 数据与文字的表示方法2.1.1 数据格式\n表示格式一般有以下几种\n\n定点格式：数值范围有限，处理简单。\n机器中所有数据的小数点位置固定不变\n不使用记号“.”来表示小数点\n定点数表示成纯小数或纯整数\n\n\n浮点格式：数值范围很大，处理过程复杂\n十进制数格式\n非压缩BCD\n压缩BCD\n\n\n\n\n定点数的表示方法\n\n\n\n\n真值是机器数/机器码代表的实际的值，机器数是真值在机器中的表示\n\n常用的（有符号数）机器码包括\n\n原码、补码、反码、移码\n\n\n原码表示法：说白了就是第一位做符号位，后面的全部当作数据位。\n\n定点小数：\n定点整数：\n0表示。分为+0和-0。+0第一位是0，其他都是0。-0第一位是1，其他的都是0.\n原码表示简单明了非常直观。但基于原码的加减法很容易出问题。\n\n\n\n\n补码表示法：\n\n定点小数：\n定点整数：负数就是取反加一那一套仍然能用。\n0的表示：就是全0，没有正负之分。\n\n\n反码表示法：这个很直观，就是对于负数：1变成0，0变成1.\n\n定点小数：\n定点整数：\n0的表示：+0就是全0，-0就是全1.\n\n\n移码表示法：在真值X的基础上加一个常数偏移值bias，通常为.\n\n \n\n\n四种表示方法的比较：\n\n若表示的数为整数，则原码、反码和补码表示的都是这个数的二进制形式\n最高位为符号位\n原码、反码、补码都是0表示正，1表示负\n移码是1表示正，0表示负\n\n\n0的表示：\n补码和移码有唯一编码\n原码和反码有两种编码\n\n\n移码和补码的尾码相同，只是符号位相反\n补码、反码和移码的符号位在加减运算时可以当作为数值看待，但原码的符号位必须单独处理 \n\n\n数据格式长度： \n\n算数移位的法则（有符号的移位法则）\n\n符号位保持不动\n正数：原码、补码、反码均补0\n负数：\n原码：补0\n补码：左移补0，右移补1\n反码：补1\n\n\n\n\n浮点数的表示：一个任意进制数N可以表示为：\n\nM是浮点数尾数，是一个纯小数\nE是比例因子的指数，称为浮点数的指数，是一个整数\nR是比例因子的基数，在二进制机器中通常规定为2、8或16\n\n\n机器浮点数的组成（比例因子基数取2）： \n\n尾数通常为纯小数，用原码或补码表示。尾数的有效数字的位数决定了浮点数的表示精度\n指数为定点整数，称为阶码，常用移码或补码表示，阶码的位数决定了浮点数的表示范围\n\n\nIEEE 754浮点数标准：\n\n如图：\n真值:（）\n小数字段Frac\n规格化数表示，隐含最高位1:\n非规格化数表示：\n\n\n关于浮点数十进制和二进制的转换\n二进制转十进制：这个没什么好说，套公式就行\n十进制转二进制，先将纯小数转化为分数：\n如果分母是2的整数次方，则转换结果是准确的\n如果分母不是2的整数次方，则转换结果是近似的，这就要求：\n求出足够多的有效位\n根据精度要求截断多余的位\n按标准要求给出符号位、阶和尾数。\n前面的蓝色部分是直接对整数部分进行转换，后面的红色小数部分则是照搬每次计算后的整数位。\n\n\n\n\n\n\n\n\n\n\nIEEE 754 32位浮点数总结（这图里的M指的是frac，ppt有问题）：\n\n十进制数表示方法：\n\n字符串形式：一个字节存放一个十进制的数位或符号位\n压缩的十进制数：一个字节存放两个十进制的数位\n用四位二进制表示一位十进制，16个编码状态选用其中的10编码状态\n多种BCD方案\n8421\n余3\n循环\n\n\n\n\n\n\n\n2.1.3 字符的表示方法\n字符型数据用ascii码表示。共128个字符，7位二进制编码，最高位补0，凑足一字节。\n\n汉字编码：\n\n汉字输入到计算机-汉字输入编码\n计算机内部的表示和存储-汉字内码\n计算机向外部显示和打印-汉字字形（字模）码\n\n\n汉字输入编码\n\n数字编码。一般采用国际区位码。用所在的区和位对汉字进行编码，称为区位码，这个码是唯一的，且不会有重码字。\n拼音码\n字形编码\n\n\n汉字内码：用于汉字存储和检索的机内代码。一般采用两个字节表示。英文字符的机内代码是七位ascii码，最高位为‘0’，为了与ASCII码相区分，汉字机内代码中两个字节的最高位均规定为‘1’.\n\n汉字机内码、国标码和区位码三者之间的关系为：区位码（十六进制）的两个字节分别加20H（32）得到对应的国标码；汉字交换码（国标码）的两个字节分别加80H（128）得到对应的机内码；\n\n\n汉字字模码（输出码）：用点阵表示的汉字字形代码。是汉字的输出形式。\n\n校验码。书上就给了奇校验和偶校验，和以前学的一个意思。\n\n\n2.2 定点加法、减法运算省了，没啥好讲的。加完后取模，减法当加法算，正溢出负溢出，都是以前学过的。\n","tags":["课程"]},{"title":"进行一个计网的润","url":"/2022/01/16/jiwang/","content":"参考的是谢希仁的第七版。很粗略地过一下知识点，开学后会有开学后的笔记。写这篇只是对计网有个大概印象。很多细节有待补充。\n第一章 概述一整章的名字就叫概述。很牛。\n第一节没啥东西。跳了。\n1.2 互联网概述1.2.1 网络的网络\n网络 Network：由若干结点 Node 和连接结点的链路 Link 组成 \n互联网 internet：网络之间用路由器连接起来。也被称为网络的网络 network of network\n网络连接计算机，互联网将网络通过路由器连接起来。与网络连接的计算机称为主机 host。互联网往往用一朵云表示。\n\n\n因特网 Internet：首字母大写为专有名词。指当前全球最大的的特定计算机网络。采用TCP/IP协议族作为通信规则，前身是美国ARPANET。\n\n1.2.2 互联网基础结构发展三个阶段\n第一阶段：单个网络ARPANET发展为互联网\n第二阶段：逐步建成三级结构的因特网\n第三阶段：逐步形成了多层ISP结构的因特网\n\n。\n\nISP（Internet Service Provider） 互联网服务提供商。\nISP的不同层次：\n主干ISP：第一层，面积最大，往往是国家范围。\n地区ISP：第二层，与主干ISP相连\n本地ISP：第三层，直接连接用户。可以和地区ISP相连也可以直接和主干ISP相连。\n\n\nIXP（Internet eXchange Point） 互联网交换点：允许两个网络直接相连，而不必通过第三个网络。比如直接在两个地区ISP中间插一个IXP，就节省了经过主干ISP的时间和资源。\n\n1.2.3 互联网的标准化工作\n几个部门\nISOC 互联网协会\nIAB 互联网体系结构委员会。从属于ISOC \nIETF 互联网工程部。从属于IAB。负责中短期工程问题，主要针对协议开发和标准化。\nIRTF 互联网研究部。从属于IAB。负责理论研究和长期问题。\n\n\n制定互联网/因特网标准的阶段：\n互联网/因特网草案（Internet Draft）：这个阶段还不是RCF文档\n建议标准（Proposed Standard）：这个阶段开始称为RCF文档。\n互联网/因特网标准。并非所有RCF文档都会变成因特网标准，只有其中一小部分会成为因特网标准。\n之前还有一个草案标准阶段，但是在2011年10月取消了这个阶段。\n\n\n\n\n\n1.3 互联网/因特网的组成\n边缘部分：所有连接在因特网上的主机组成。用户直接使用\n核心部分。由大量网络和练连接这些网络的路由器组成。这部分用以给边缘部分提供服务。\n\n1.3.1 互联网的边缘部分\n连接在互联网上的所有主机被称为端系统（end system）\n端系统之间的通信方式（主机之间的通信方式）：\n客户-服务器方式 C/S：其中一个主机是服务请求方（客户程序），另一个主机是服务提供方（服务器程序）。\n对等连接方式 P2P：不区分主机和服务器，两台主机处于平等地位。也可以认为两台主机都是服务器也都是主机。\n\n\n\n1.3.2 互联网的核心部分\n路由器 router：在核心部分起特殊作用。实现分组交换 packet switching的关键构件。任务是转发收到的分组。\n\n交换 Switching：按照某种方式动态地分配传输线路的资源。\n\n\n接下来讲三种交换方式：\n\n电路交换 Circuit Switching：电路交换机接通电话线的方式。这种交换方式必须经过三个步骤：\n\n建立连接（分配通信资源）\n通话（一直占用通信资源）\n释放连接（归还通信资源）\n用这种交换方式来传输计算机数据会导致资源浪费\n\n\n\n\n分组交换 Packet Switching：采用存储转发技术。将报文（message）划分为更小的等长数据段，之后为每个数据段添加首部（header）来构成一个分组（packet）。然后将所有分组交给网络，让其最终被交付到正确的传输终点。\n\n分组交换的三个部分\n发送方：构造分组和发送分组\n路由器：缓存分组和转发分组\n接收方：接受分组和还原报文\n\n\n\n\n报文交换 Message Switching：也采用存储转发技术。已经被分组交换技术取代。\n\n三种交换方式的对比\n\n电路交换：建立连接后整个报文从源点直达终点。通信结束后释放连接。\n优点：\n通信时延小\n有序传输\n实时性强\n\n\n缺点\n建立连接时间长\n线路独占，使用效率低\n灵活性差\n\n\n\n\n报文交换：不需要建立连接。整个报文在相邻节点中传输，直到抵达终点。结点将整个报文存储下来后查看转发表，之后再转发到下一个结点。\n优点\n无需建立连接\n动态分配线路\n提高线路利用率\n提供多目标服务\n\n\n缺点\n引起了转发时延\n需要较大的存储缓存空间\n需要存储额外的信息量\n\n\n\n\n分组交换：不需要建立连接。先将报文切割成分组，然后每个分组在节点中传输，依次抵达终点。存储后查看转发表，转发给下一个结点。\n优点\n报文交换的所有优点\n简化存储管理。使用分组管理，比报文管理要简洁\n加速了传输\n减少了出错概率和重发数据量。分组错误率会比报文更低，出错了也只需要重传分组。\n\n\n缺点\n转发时延\n额外信息量\n可能存在分组失序，缺失，重复的问题。\n\n\n\n\n\n\n\n1.4跳了。没啥东西。\n补：计算机网络的组成\n从组成部分来看，完整的计算机网络主要由硬件、软件、协议组成。\n从工作方式看，计算机网络可以分成边缘部分和核心部分。\n功能组成上看，计算机网络由通信子网和资源子网组成。通信子网由各种传输介质、通信设备和相应的网络协议组成。资源子网是实现资源共享功能的设备及其软件的集合。\n\n补：计算机网络的功能\n数据通信。最基本也最重要的功能。\n资源共享。\n分布式处理。\n提高可靠性。\n负载均衡。\n\n1.5 计算机网络的类别1.5.1 关于计算机网络的定义\n计算机网络最简单的定义：一些互相连接的、自治的计算机的集合。即要求如下：\n互连：计算机之间可以通过有线或者无线的方式进行数据通信\n自治：独立的计算机，具有自己的硬件和软件，可以单独运行使用\n集合：至少有两台计算机\n\n\n关于计算机网络的较好定义：计算机网络主要是由一些通用的、可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件可以用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。\n也就是说计算机连接的硬件中不仅限于计算机，也可以包含智能手机等硬件。（但可编程意味着硬件中需要有中央处理器CPU）\n计算机网络并非专门用来传输数据，而是可以支持很多种的应用。\n\n\n\n1.5.2 计算机网络的分类按照不同的分类角度进行分类\n\n按交换技术分类\n\n电路交换网络\n报文交换网络\n分组交换网络\n\n\n按使用者分类\n\n公用网。任何按电信公司规定缴纳费用的人都可以使用的网络。\n专用网。某个部门为了满足本单位特殊业务工作需要而建造的网络。\n\n\n传输介质分类\n\n有线网络\n无线网络\n\n\n覆盖范围分类\n\n广域网WAN\n城域网MAN\n局域网LAN。传统上，局域网使用的是广播技术，广域网使用的是交换技术。二者使用的协议有差别，使用的协议差异也是区分局域网和广域网的主要依据。\n个人区域网PAN\n若中央处理机之间的距离非常近，则一般称之为多处理机系统，而不称为计算机网络。\n\n\n\n\n拓扑结构分类\n\n总线型网络。\n星型网络。\n环型网络。\n网状型网络。\n\n\n传输技术分类\n\n广播式网络。所有联网计算机共享一个公共通信通道。\n点对点网络。每条物理线路连接一对计算机。广域网一般都是点对点网络。是否采用存储转发技术和路由选择技术是区分这两种的标准。\n\n\n接入网 AN（Access Network）:用户端系统到互联网中第一个路由器之间的一种网络。\n\n\n1.6 计算机网络的性能1.6.1 计算机网络的性能指标\n速率：速率指的是数据的传送速率，指的是数据率。需要注意的是数据量和数据率中的相同单位表示不同的大小。比如数据量中的表示（B（8b）），但数据率中的表示（b/s(bps)）。之后的单位，数据量中以递增。数据率中以递增\n\n带宽:计算机网络中，表示单位时间内网络中的某信道所能通过的”最高数据率“。带宽的单位是bit/s。单位意义和数据率是一致的。\n\n吞吐量:单位时间内通过某个网络（或信道，接口）的实际的数据量。吞吐量的上限就是带宽。\n\n时延:数据从网络一端到另一端所需要的时间。一般由以下几个部分组成，\n\n发送时延：指的是主机或者路由器发送数据帧所需要的时间。计算公式为发送时延数据帧长度发送速率\n传播时延：电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式：传播时延信道长度电磁波在信道上的传播速率\n处理时延：主机或路由器在收到分组花费一定的时间进行处理，所花费的时间就是处理时延。\n排队时延：分组在进入路由器后要排队等待处理，处理后要排队等待转发，这就产生了排队时延。排队时延的长短取决于当前通信量的大小。\n有些教材中会把排队时延和处理时延合并为处理时延。总时延是这些时延的和。\n\n\n\n\n时延带宽积:是传播时延和带宽的乘积，单位是bit。也可以视为是以比特为单位的链路长度。\n\n往返时间 RTT:信息双向交互一次的所需时间。即从源主机发送分组到源主机收到目的主机的确认分组为止的所需时间。\n\n利用率:\n\n信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过）\n网络利用率：全网络的信道利用率的加权平均用表示网络空闲时的时延，表示网络当前时延，表示利用率。那么关系可以以下公式计算：\n信道利用率并非越高越好。如公式，利用率到50%时，网络时延就达到了2。利用率越高网络时延也就越高。\n\n\n\n\n\n有的教材中还会提到丢包率。但我这本没有。所以不写了。1.6.2跳了。好像不是很重要。\n\n关于时延的计算问题。稍微提一嘴，好像考的比较多。\n\n1.7 计算机网络体系结构1.7.1 计算机网络结构的形成\n法律上的国际标准是OSI\n事实上的国际标准是TCP/IP\n\n1.7.2 协议与划分层次\n网络协议（network protocol）：为网络中的数据交换而建立的规则、标准或约定。一般由以下三个要素构成\n语法。数据与控制信息的结构或者格式。\n语义。即需要发出何种控制信息，完成何种动作和作出何种响应。\n同步。即事件实现顺序的详细说明。\n\n\n\n为了方便操作，一般会将协议区分为不同的模块进行分层管理。位于上层的模块可以调用下层的模块。\n\n网络的体系结构 architecture指的就是计算机网络的各层及其协议的集合。 \n\n1.7.3 具有五层协议的体系结构OSI七层协议，TCO/IP四层协议，书上为了方便理解和学习，给的是五层协议，如图：\n\n应用层 application layer：体系中的最高层，通过应用进程之间的交互来完成特定的网络应用。应用层定义的是应用进程间的通信和交互规则。这里一般采用大量多种的应用协议。\n运输层 transport layer：负责向两台主机中进程之间的通信提供通用的数据服务。应用进程通过利用该服务传送应用层报文。可以复用和分用。主要使用以下两种协议。\n传输控制协议TCP：提供面向连接的、可靠的数据传输服务，数据传输单位是报文段\n用户数据报协议UDP：提供无连接的，尽最大努力的（best effort）的数据传输服务，数据传输用的单位是用户数据段。UDP是不可靠的，而TCP是可靠的。\n\n\n网络层 network layer：负责为网上的不同主机提供通信服务。发送数据时，网络层负责把运输层产生的报文段或者用户数据报封装成分组或包进行传输。网络层的另一个任务是选择合适的路由。有时也称为IP层或者网际层。一般采用IP协议。\n数据链路层 data link layer：链路层负责将网络层交下来的IP数据组装成帧。相邻结点之间传送帧。\n物理层 physical layer：物理层上传输的数据单位是比特。物理层考虑用多大的电压表示“1”和“0”，以及接收方怎么识别、以及连接电缆的插头应当有多少根引脚等。传递信息使用的具体的物理媒介不是物理层考虑的范围。\nTCP/IP中，数据链路层和物理层合并为网络接口层。可靠服务指的是在传输前会建立连接，而不可靠服务不会建立连接，直接进行数据传输，但这样就不能保证信息的正确性。\n\n\n\n\n\n关于各层的应用范围\n\n1.7.4 实体、协议、服务和服务访问点这一块就是一大堆的术语。\n\n实体 entity：表示任何可发送或接收信息的硬件或软件进程。\n对等实体：通信双方中相同层次的实体。比如应用层对应应用层，运输层对应运输层等，网卡对应网卡之类的。\n协议：控制两个对等实体进行逻辑通信的规则的集合。\n协议三要素\n语法：定义交换信息的格式。\n语义：定义收发双方所要完成的操作。\n同步：定义通讯双方的时序关系。\n\n\n\n\n在协议的控制下，两个对等实体之间的逻辑通信使得本层可以向上一层提供服务。实现本层协议，还需要使用下面一层所提供的服务。\n协议是水平的，服务是垂直的。\n\n\n服务访问点 SAP：同一系统中相邻两层实体进行交互的地方。\n服务原语：上层使用下层服务时与下层交换的命令。\n协议数据单元 PDU：对等层次之间传送的数据包称为该层的协议数据单元。\n服务数据单元 SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。不同层的PDU称呼不同，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。\n协议控制信息 PCI：控制协议操作的信息。\n多个SDU可以合成为一个PDU，一个SDU也可以划分为多个PDU。\n传输数据时，把n+1层的PDU作为第n层的SDU，然后加上第n层的PCI，就构成了第n层的PDU。\n\n补：OSI的参考模型（包含结构层的详细描述）\n\n物理层：\n\n传输单位是比特\n物理层主要研究以下内容\n通信链路和通信结点的连接需要一些电路接口，物理层定义了接口的一些参数。比如机械形状和尺寸等。\n规定了通信链路上传输的信号的意义和电气特征。例如可以规定信号A代表数字0，以此类推，给信号赋予意义。\n注意：传输信息用的物理媒体，例如光缆，双绞线等不再物理层协议之内而在物理层协议之下。因此物理媒体也可以认为是第0层。\n\n\n\n\n\n\n数据链路层\n\n传输单位是帧。任务是将网络层给的IP数据组装成帧。\n作用主要概括为成帧，差错控制，流量控制和传输管理等。\n成帧就是指将IP数据组装为帧。\n差错控制。指通过数据链路层的协议可以判断比特流的传输有没有出错。\n流量控制。指协调两个结点之间的速率，避免两个结点的发送速率和接收速率相差太大而导致数据丢弃。\n\n\n\n\n网络层\n\n传输单位是数据报。主要任务是把网络层的PDU（分组）从源端传输到目的端。\n关键问题是实现路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。\n路由选择。就是用网络层的路由算法算出一条更适合的分组传输路径\n流量控制。这个和数据链路层的流量控制意义是一样的。\n差错控制。两个通信结点之间判断分组的传输有没有出错。出错了能纠错就纠错，不能就丢弃。\n拥塞控制。如果所有结点都来不及接受分组，处于要丢弃大量分组的状态，就称这为拥塞状态。拥塞控制就是指网络层会采取一定措施来缓解拥塞，\n\n\n\n\n传输层\n\n传输单位是TCP或UDP。负责两个主机中进程的通信。提供的是端到端的服务\n数据链路层提供的是点到点（IP地址和IP地址）的通信，传输层提供的是端到端的通信\n提供流量控制、差错控制、服务质量、数据传输管理等服务。\n复用和分用。复用即多个应用进程可以同时使用下面传输层的服务，分用即传输层把接受到的信息分别交付给应用层中相应的进程。\n\n\n会话层：构建两个进程之间的会话。\n\n表示层：主要处理两个通信系统之间交换信息的表示方式。\n\n应用层：最高层，是用户和网络的界面。由于应用多种多样，所以应用层的协议多种多样。\n\n\n1.7.5 TCP/IP的体系结构\n\n网络接口层：类似于OSI的物理层和数据链路层。\n网际层：类似于OSI网络层。网际层定义了标准的分组格式和协议，即IP。\n传输层：类似于OSI传输层。协议一般是TCP和UDP。\n\n第二章 物理层2.1 物理层的基本概念\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\n物理层为数据链路层屏蔽了各种传输媒体的差异。使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑具体的传输媒体是什么。\n物理层协议的主要任务：定义特性\n机械特性。指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。\n电气特性。指明接口上各条线出现的电压的范围。\n功能特性。指明某条线上出现的某一电平的电压表示何种意义。\n过程特性。指明对于不同功能的各种可能事件的出现顺序。\n\n\n\n2.2 物理层下面的传输媒体一般分为导引型传输媒体和非导引型传输媒体。\n\n导引型传输媒体：需要相应的固体媒介的媒体。\n同轴电缆:\n双绞线：两根互相绝缘的铜线按照一定规则进行绞合形成了双绞线。\n无屏蔽双绞线UTP电缆。\n屏蔽双绞线STP电缆。相比无屏蔽双绞线增加了金属丝编织的屏蔽层。\n\n\n光纤:\n多膜光纤：\n单膜光纤：\n\n\n电力线\n\n\n非导引型传输媒体（无线传输介质）\n无线电波\n微波：\n直线传播，可以穿透电离层\n应用：地球同步卫星，低轨道卫星\n地面100m发生塔，最大视距LOS传输距离为100m\n\n\n红外线\n可见光\n\n\n\n2.3 传输方式\n串行传输：每次发送一个比特。一条传输线路。用于计算机之间的数据传输。\n并行传输：每次多个比特。多条传输线路。速度快成本高。一般用于计算机内部的数据传输。\n同步传输：数据以比特流的形式传输，中间没有间隔。接收端在比特信号的中间时刻进行检测，来判断收到的是比特0还是比特1。为了减少判别偏移累积形成的判别错位，一般采取以下两种方式来确保发送端和接收端的时钟同步。\n外同步。在收发双方之间添加一条单独的时钟信号线。\n内同步。发送端将时钟同步信号编码到发送数据中一起传输。（例如曼彻斯特编码）\n\n\n异步传输：以字节为单独独立的传输单位，字节之间的时间间隔不是固定的。接收端仅在字节的起始处对字节内部实现同步。因此要在字节前后加上起始位和结束位。异步指的是每个字节之间异步，而字节之间的每个比特仍然同步。\n单向通信（单工）：通信双方只有一个传播方向，如无线电广播。只需要一条信道。\n双向交替通信（半双工）：通信双方可以相互传递数据，但不可以同时进行。例如对讲机。需要两条信道，每个方向各一条。\n双向同时通信（全双工）：通信双方可以同时发送和接收信息。例如电话。需要两条信道，每个方向各一条。\n\n2.4 编码和调制有一大堆概念，给一张图解释一下。\n\n\n编码：在不改变信号性质的前提下，仅对数字基带信号的波形进行变换，称为编码。编码完成后的信号仍为数字信号，可以在数字信道中传输。\n\n调制：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生的信号为模拟信号。可以在模拟信道中传输。\n\n对于模拟基带信号的处理也有编码和调制两种。结果和对数字基带信号处理结果一致，分贝产生了数字信号和模拟信号。\n\n\n码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。即码元就是构成信号的一段波形。\n\n传输媒体和信道的关系：对于单工传输，那么要包含一个发送信道。如果是半双工或者全双工传输，则要包含发送信道和接收信道。而如果使用了信道复用技术，一条传输媒体还可以包含多个信道。\n\n常用编码：\n\n不归零编码NRZ：正电平为1，负电平为0.不归零指的是整个码元时间内不会出现零电平。但由于不归零编码有同步问题，强行同步会浪费资源，所以计算机中不采用这种编码方式。\n归零编码RZ：每个码元传输结束之后都要归零。所以接收方只要在信号归零后采样即可，不需要单独的时钟信号，相当于归零编码通过”归零”的方式把时钟信号编码到数据之中。这称为自同步信号。但编码中的大部分数据带宽都因为传输”归零“而被浪费了。因此归零编码是自同步编码，但是编码效率低。\n曼彻斯特编码：每个码元的中间都会产生“跳变”。正负跳变是1还是0不一定，可以自行假设。码元中间时刻的跳变即表示时钟又表示数据。传统以太网使用的就是曼彻斯特编码。\n差分曼彻斯特编码：和曼彻斯特编码不同，跳变仅表示时钟。用码元开始处电平是否发生变化来表示数据。差分曼彻斯特编码变化比曼彻斯特编码少，更适合高效率的传输。\n\n\n基本调制方法：\n\n调幅（AM）：无载波表示比特0，有载波表示比特1.\n调频（FM）：频率f1的波形表示比特0，频率f2的波形表示比特1.\n调相（PM）：初相位0度的波形表示比特0，初相位180度的波形表示比特1.采用基本调制方法，每个码元只能包含一个比特信息.可以采用混合调制方法让一个码元中可以包含更多比特的信息。\n\n\n混合调制：一般考虑三个变量。频率、相位和振幅。其中频率和相位相关，所以调整一个就相当于调整了另一个。所以一般情况下混合调制考虑调整的是相位和振幅。称为正交振幅调制QAM。\n\nQAM-16：\n12种相位\n每种相位有1或2种振幅可选。\n一共可以调制出16种码元（波形），每种码元可以对应4个比特。\n码元和4个比特的对应关系采用格雷码，任意两个相邻码只有一个比特不同。\n\n\n\n\n\n2.5 信道的极限容量信号波形通过信道时会产生一定程度的失真。失真不严重时可以识别波形，失真严重时无法识别输出波形。\n\n失真因素\n\n码元传输速率\n信号传输距离\n噪声干扰\n传输媒体质量\n\n\n奈氏准则：在假定的理想条件下，为了避免码间串扰，码元的传输速率是有上限的。即理想低通信道的最高码元传输速率码元秒理想带通信道的最高码元传输速率码元秒其中W为信道带宽（单位为Hz），Baud为波特，即码元/秒。\n\n码元传输速率又称为波特率、调制速率、波形速率或符号速率。与比特率有一定关系：\n\n当1个码元只携带1比特的信息量时，波特率（码元/秒）和比特率（比特/秒）在数值上是相等的。\n当1一个码元携带n比特的信息量，则波特率转换成比特率时，数值要乘以n。\n\n\n要提高信息传输速率（比特率），就必须设法使每一个码元可以携带更多个比特的信息量，这需要采用多元制。\n\n实际信道所能传输的最高码元速率，明显低于奈氏准则给出的上限数值。\n\n注意：并不是一直提高码元携带的比特数量，就可以无限提高信息的传输速率。因为还要受限于实际信号在信道中传输的信噪比。\n\n\n香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。\n\nc：信道的极限信息传输速率（单位 b/s）\nW:信道带宽（单位 Hz）\nS：信道内所传送信号的平均功率\nN：信道内的高斯噪声功率\nS/N：信噪比，使用分贝（dB）作为度量单位。一般题目中给的都是信噪比，要自己换算成S/N信噪比（）\n\n\n从香农公式中可以看出，信道带宽或信道中信噪比越大，信息的极限传输速率越高。\n\n实际信道中可以达到的信息传输速率低于该公式的极限传输速率。因为还要受到其他因素的损伤。\n\n从奈氏准则和香农公式中来看，要提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比。\n\n\n第三章 数据链路层3.1 数据链路层概述\n链路（Link）：就是从一个结点到相邻节点的一段物理线路，而中间没有其他的交换结点。\n数据链路（Data Link）：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。\n数据链路层以帧为单位传输和处理数据。\n数据链路层的三个最基本也最重要的问题：\n封装成帧：数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作，称为封装成帧。\n差错检测：发送方在发送帧之前，基于待发送的数据和检错算法计算出检错码，然后将其封装在帧尾。接收方以此来判断传输过程中是否产生了误码。\n可靠传输：尽管误码是不能完全避免的，但若能实现发送方发送什么，接收方最终都能收到相应的正确内容，就称为可靠传输。\n\n\n对于使用广播信道的数据链路层（相当于主机都连在一条线上。即共享式局域网）存在一些别的问题。\n如何确保数据被正确的主机接收：在帧中插入了源地址和目的地址\n如何解决传输信号碰撞的问题：以太网的解决措施是接入控制协议CSMA/CD，也就是载波监听多点接入/碰撞检测。\n\n\n现在大多采用交换式局域网而非共享式局域网。\n\n3.2 封装成帧\n\n定义：封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。\n帧头和帧尾包含有重要的控制信息\n帧头和帧尾的作用之一就是帧定界（确认哪一段是一个帧)。例如ppp帧就可以通过帧头和帧尾的标志进行帧定界。MAC帧中没有标志，是因为以太网V2会在物理层中添加前导码作处理。同时以太网还规定了一定间隔的帧间间隔。\n\n\n透明传输：透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。 为了达到这一点，会在上层交付的数据中可能引起误解的部分的前端填充转义字符。（如上层交付数据中和将要加入的帧标志相同的部分。）\n面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。\n面向比特的物理链路使用比特填充的方法实现透明传输。下图为例（比特填充）：其中的标志为0111110.而在帧的数据部分中存在和标志相同的部分，为了避免误解，在这几个部分的每5个1后添加一个0，这样就确保了帧定界在整个帧中的唯一性。这个方法是HDLC协议中所采用的。\n\n\n为了提高帧的传输效率，应当使帧的数据部分长度尽可能大一些。但考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU。\n\n3.3 差错检测\n实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能会变成1.这称为比特差错。\n而一段时间内，传输错误的比特占总传输比特总数的比率称为误码率BER（Bit Error Rate）\n使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层索要解决的重要问题之一。\n奇偶校验：在待发送的数据后面添加一位奇偶校验码，使整个数据（包括所添加的校验码在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。\n如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码。如果偶数个位发生误码，奇偶性不发生改变，不能检查出误码（漏检）。这就导致奇偶校验的漏检率较高，因此计算机的数据链路层一般不会采用这种检测方式。\n\n\n循环冗余校验CRC（Cyclic Redundancy Check）\n收发双方约定好一个生成多项式G（x）；\n发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），并将其添加到待传输数据的后面一起传输。\n接收方通过生成多项式来计算收到的数据是否产生了误码。如图，图中的计算为除法。eg1：eg2:\n\n\n检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。。想要纠正差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。\n循环校验码CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但是非常易于用硬件实现，因此广泛应用于数据链路层。\n在计算机网络中通常采用检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向上层提供的是可靠传输服务还是不可靠传输服务。\n\n3.4 可靠传输3.4.1 可靠传输的基本概念\n对于误码，数据链路层向上层提供的服务类型\n不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做；\n可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。\n\n\n一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务，即使出现了误码，可靠传输的问题由其上层处理。\n无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。\n比特差错只是传输差错中的一种。\n从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。\n分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。\n可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。\n可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。\n\n3.4.2 停止-等待协议SW(Stop-and-Wait)先上图：\n按照图的顺序进行解释：\n\n确认与否认：在SW中，发送方发送数据（Data）后，如果没有误码，接收方要对发送方发送一个确认分组（ACK）。如果有误码，接收方丢弃该数据分组，并向发送方发送一个否认分组（NAK）。发送方收到否认分组后要重传之前的数据分组，因此发送方发送完数据分组后不能立即将分组从缓存中删除，只有收到确认分组后才可以将其删除。\n超时重传：如果发送方发送的数据分组在传输过程中丢失了，那么接收方不会对发送方发送任何NAK或者ACK，这会导致发送方无法继续操作。因此发送方每次发送数据分组后会启动一个超时计时器，若到了超时计时器的设置时间而仍然收不到ACK或者NAK，则重传原来的数据分组。这就是超时重传。一般这个时间设置为略大于”从发送方到接收方的平均往返时间“。\n确认丢失：如果接收方给发送方所发送的ACK丢失，那么启动超时重传后会导致发送方接收了重复的数据分组。如果不做处理而直接接收，会导致分组重复而出现传输差错。采取的解决办法是对发送方发送的数据分组进行比特编号（使用结尾0或1编号）。这样只要保证这次收到的数据分组编号和上一次不同即可。\n确认迟到：如果ACK没有丢失，但抵达时间长于了超时重传的时间，就会让DATA0超时重传。而接收方收到重复分组DATA0后，将其丢弃后向发送方发送了重复分组DATA0的ACK。如图，如果不对这个ACK进行编号，那么发送方会误以为这是对DATA1的确认ACK，而导致发送乱序。因此，对于接收方的回传分组也需要编号。\n数据链路层的点对点协议一般不会出现确认迟到的情况，所以如果只是在数据链路层使用SW协议，可以不用给确认分组编号。\n\n\n\n总结如下：\n\n停止-等待协议的信道利用率：\n：发送方发送数据分组所耗费的发送时延。\n：双方之间的往返时延\n:接收方发送确认分组所耗费的发送时延\n因此，总时间为，由于用来发送数据分组的时间才是有效时间，所以信道利用率表示为其中一般远小于，可以忽略。\n可以看出，当往返时延远大于数据发送时延时（例如使用卫星链路），信道利用率非常低。\n\n\nSW协议是停止等待ARQ协议。3.4.3 回退N帧协议GBN(Go-Back-N)\n\nSW中是一个一个数据分组的方式进行发送，而GBN中采用的是多个数据分组的形式进行发送，具体如下图：\n这里取n为3，因此可编号为0-7。GBN中分为发送方的发送窗口（1&lt;&lt;，本例中取5）和接收方的接收窗口（和SW一致为1）。\n\n无差错情况：发送方一次性发送了编号0-5的数据分组，假设在没有出现乱序和误码的情况下抵达了接收方。接收方每接收一个，接收窗口就往后滑动一个位置，每滑动一次，就给发送方发送针对所接收分组的确认分组。而发送方每接收一个确认分组，发送窗口就往后滑动一个位置，这样就有新的编号的数据分组落入了发送窗口，从而被发送。发送方也可以将被确认的数据分组从缓存中删除。\n\n累积确认：对于采用GBN的接收方，可以采用累积确认的方式。即接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定），对按序到达的最后一个数据分组发送确认。表示序号为n之前的所有数据分组都已经被正确接收。\n\n累积确认的一个好处是ACK丢失的影响会变小，有时即便确认分组丢失，发送方也不必进行数据分组重传，譬如本例中取每接收两个数据分组后就发送确认分组，第一轮接收时就会发送和，那么即使丢失了，只要抵达了，那么发送方就知道数据分组0~4都成功接受了，而不必重新发送数据分组0和数据分组1.\n\n\n出现差错的情况：假设本例中第一轮数据传输成功，即成功传输。但在传输数据分组出现差错，导致出现了误码。那么接收方接收时就会把丢弃。而即使后面的四个数据分组没有差错，但无法和此时接收窗口所要求的数据分组（即正确的）对应，因此接收方也会将后续的四个数据分组丢弃。接收方每丢弃一个数据分组就会对发送方发送一个之前的确认分组(本例中是)，来表明分组出错。发送方收到了重复的确认分组，就可以意识到之前的分组发送出现了问题，因此可以不等到超时重传就立刻重传。至于收到几个重复分组后再立刻重传，取决于具体实现。若没有触发立即重传，那么超时后发送方就会继续发送发送窗口里的内容，而由于一直收到重复确认分组，导致发送窗口没有移动，所以仍旧相当于把之前的内容重复发送了一遍。\n\n可以看出，当通信线路质量不好时，GBN的信道利用率并不以SW的高。\n\n\n注意：如果的取值大于了最大编号。那么当ACK丢失的时候，发送方的超时重传会导致接收方无法分辨新、旧分组，从而导致分组重复。\n\n\n总结如下：\n\nGBN是在流水线传输的基础上利用发送窗口限制发送方连续发送数据分组的数量，是一种连续ARQ协议\n再协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议。\n由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比SW协议高。\n\n3.4.4 选择重传协议SR（Selective Request）由于GBN的只能等于1，因此一个数据分组的误码会导致后续多个数据分组不被接收而被丢弃。这会导致发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。为了进一步提高性能，可以设法只重传出现误码的数据分组，因此，接收窗口尺寸应当大于1.以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组。等到所缺分组收齐后再一并送交上层。这就是选择重传协议\n\n注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。\n\n如图：其中的取数规则和GBN相同，而。\n接收方只要接收了相应的分组，都会对发送方发送确认分组。但只有在按序接收的情况下，接收窗口才会向后滑动。而发送方只要接收到了确认分组，都会对相应的数据分组进行标记，以表明该分组已经发送成功。但只有在按序标记完的情况下，发送窗口才会向后滑动。\n总结如下：\n3.5 点对点协议PPP(Point-to-Point Protocol)\n点对点协议PPP是目前使用最广泛的点对点数据链路层协议\nPPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已经成为因特网的正式标准。\nPPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：\n对各种协议数据报的封装方法（封装成帧）\n链路控制协议LCP。   用于建立、配置以及测试数据链路的连接。\n一套网络控制协议NCPs。   其中的每一个协议支持不同的网络层协议\n\n\n\n\n\nPPP的帧格式：如图\n\nF：标志字段。取值为0x7E（二进制的01111110）\nA:0xFF。目前没用\nC:0x03。目前没用\nP：指明帧的数据部分交由哪个协议处理\n0x0021:IP数据报\n0xC021：LCP分组\n0x8021：NCP分组\n\n\nF：帧检验序列字段。CRC计算出的校验位。\n\n\nPPP协议的透明传输：即当帧的数据部分出现了F（01111110）时的处理办法\n\n对于面向字节的异步链路：采用字节填充法。插入转义字符。\n发送方：\n出现的每一个7E（PPP帧的定界符）字节转变成2字节学列（7D，5E）\n出现的每一个7D（转义字符）字节转变成2字节序列（7D，5D）（不包括后来加上去的7D）\n出现的每一个ASCII码控制字符（数值小于0x20的字符），则在该字符前面插入一个7D字节。同时将该字符的编码加上0x20\n\n\n接收方：按照发送方的步骤进行反变换即可。\n\n\n对于面向比特的同步链路：采用比特填充法。即\n发送方：对帧的数据部分进行扫描（一般由硬件实现），只要发现5个连续的比特1，则立即填充1个比特0（在5个比特1后面）\n接收方：对帧的数据部分进行扫描，只要发现5个连续的比特1，就把其后的一个比特0删除。\n\n\n\n\nPPP协议的差错检测：使用CRC生成FCS字段。使用的生成多项式如下其中FCS的计算范围不包括标志字段和FCS本身。接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧。反之就丢弃这个帧。使用PPP的数据链路层向上不提供可靠传输服务\n\nPPP协议的工作状态：不太看得懂，放个图跑路了。\n\n\n3.6 媒体接入控制3.6.1 媒体接入控制的基本概念\n共享信道（多台主机连一根线）要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）\n\n媒体接入控制技术分为两种：\n\n静态划分信道。即预先分配好信道，这类方法不灵活，对于突发性数据传输信道利用率会很低。通常在无线网络的物理层中使用，而不是在数据链路层使用。\n频分多地\n时分多址\n码分多址\n\n\n动态接入控制\n受控接入。如今采用较少，基本被淘汰。\n集中控制。用一个主站以循环的方式轮询每个站点有无数据要发送。只有轮询到的站点才可以发送数据。最大缺点是单点故障问题。\n分散控制。各站点平等。连接成环型网络。其中用令牌（一种特殊的控制帧）沿着环逐站传递。有令牌的站点才有权发送数据。发送完数据后令牌传递给下一个站点。\n\n\n随机接入。所有站点竞争发送数据。\n随着技术发展，交换技术成熟和成本降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已经完全取代了共享式局域网。但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。\n\n\n\n\n\n\n\n\n3.6.2 静态划分信道\n复用（Multiplexing）：复用就是通过一条物理线路同时传输多路用户的信号。\n\n当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在物理线路上建立多条通信信道来充分利用传输媒体的带宽。\n\n常见的信道复用技术有四种\n\n频分复用FDM复用器负责把子信道区分开来。子信道之间有隔离频带隔开。分用器负责把子信道的内容分离。\n\n码分复用TDM\n\n波分复用WDM8个光载波之间每每相隔1.6nm。经光复用器合并后在光纤中传播。由于损耗，所以会在传输中采用掺铒光纤放大器EDFA。光分用器和光复用器之间可以方四个EDFA。\n\n码分复用CDM\n\n码分复用是另一种共享信道的方法。由于该技术主要用于多址接入，人们更常用的名词时码分多址CDMA。(Code Division Multiple Access)\n\n同理，频分复用FDM和时分复用TDM同样可以用于多址接入。相应名词为FDMA和TDMA。\n\n复用和多址的区别\n\n复用是将单一媒体的频带资源划分为很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。\n多址（或者更确切地称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道地应用中时必须的，而所有的移动通信系统基本都属于这种情况。相反，在信道永久性分配给用户的应用中，多址时不需要的。（比如无线广播或者电视广播站。）\n\n\n与FDM和TDM不同。CDM的每一个用户可在同样的时间使用同样的频带进行通信\n\n由于各用户使用经过挑选的不同码型，因此各用户之间不会造成干扰\n\n在CDMA中，每一个比特时间再划分为m个短的间隔。称为码片（Chip）。通常m的值是64。\n\n使用CDMA的每一个站被指派一个唯一的m bit码片序列（Chip Sequence）\n\n如果一个站要发送比特1，则发送它自己的m bit码片序列\n如果一个站要发送比特0，则发送它自己的m bit码片序列的二进制反码这也被称为直接序列扩频DSSS\n\n\n码片序列的挑选原则如下：\n\n分配给每个站的码片序列必须各不相同。实际上常采用伪随机码序列。\n分配个每个站的码片序列必须相互正交（规格化内积为零）令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列。两个不同站的S和T的码片序列正交，就是向量S和T的规格化内积为0；另外，任何码片序列自己和自己的规格化内积为1，即：同时，任何一个码片向量和其他各站码片反码的向量的内积也是0.任何一个码片向量和其自身反码的内积为-1：\n注意：向量计算时，码片序列中的0作为-1看，1作为+1看，如下：\n\n\n\n同时，接收方也可以利用规格化内积的规律来判断发送方发送了什么，如：\n\n\n\n\n\n\n3.6.3 随机接入——CSMA/CD协议早期的共享式以太网，为了解决多台主机同时发送数据，导致数据在总线里碰撞冲突的问题。采用载波监听多址接入/碰撞检测，即CSMA/CD协议（总线型局域网使用）。\n\n多址接入MA：多个站连接在一条总线上，竞争使用总线。\n载波监听CS：每一个站再发送帧之前先要检测以下总线上是否有其他站点在发送帧。\n若检测到总线空闲96比特时间，则发送这个帧。\n若检测到总线忙，则继续检测并等待总线空闲96比特时间，然后发送这个帧。\n\n\n碰撞检测CD：每一个正在发送帧的站边发送边检测碰撞。\n一旦发现总线上出现碰撞，则立即停止发送。退避一段随机时间。\n以太网还采取一种叫做强化碰撞的措施，这就是当发送帧的站点一旦检测到了碰撞，除了立即停止发送帧意外，还要继续发送32比特或48比特的认为干扰信号，以便有足够多的碰撞信号使所有站点都能检测出碰撞。\n\n\n\n\n争用期（碰撞窗口）：如图：\n主机最多经过当的时长就可以检测到本次发送是否遭受了碰撞。端到端的最大距离媒介上的传播速率\n因此，以太网的端到端往返传播时延称为争用期或者碰撞窗口。\n经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n每一个主机在自己发送帧之后的一小段时间，存在着遭遇碰撞的可能性。这一小段时间是不确定的。但不会超过总线的端到端往返传播时延，即一个争用期时间。\n显然，在以太网中发送帧的主机越多，端到端往返传播时延就越大，发生碰撞的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长。\n10Mb/s以太网把争用期定为512比特发送时间，即51.2μs，因此其总线长度不能超过5120m，但考虑到其他一些因素，以太网规定总线长度不能超过2500m。\n\n\n\n\n最小帧长：考虑到如果主机发送的帧过短，那么主机从开始发送帧到结束的这段时间内，不能够完全检测出帧在传递过程中是否会碰撞。因此以太网规定最小帧长为64字节，即512比特（512比特时间即为争用期）。\n如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。\n最小帧长数据传输速率\n\n\n以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞。\n如果在争用期没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞\n如果争用期内检测到了碰撞，就立即停止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。\n\n\n最大帧长：\n截断二进制指数退避算法\n若连续多次发生碰撞，就把表明可能2有较多的主机参与竞争信道，但使用上述退避算法可以使重传需要推迟的平均时间随着重传次数而增大（动态退避），因而减小发生碰撞的概率。有利于整个系统的稳定。\n当重传达16次仍不能成功时，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧，并向高层报告。\n\n\n信道利用率：考虑理想情况下的信道利用率，即\n各主机发送帧都不会产生碰撞\n总线一旦空闲就有某个主机立即发送帧\n发送一帧占用总线的时间为，而帧本身的发送时间为所以极限信道利用率为：\n其中参数应尽可能小，以提高信道利用率\n即以太网到端的距离应该受到限制，以太网帧的长度应尽量长些。\n\n\n帧发送流程：\n帧接收流程：\n\n3.6.4 随机接入——CSMA/CA协议无线局域网使用CSMA/CA协议，也是载波监听多址接入/碰撞避免\n\n在无线局域网中，仍然可以使用载波监听多址接入CSMA。即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发送碰撞。\n在无线局域网中，不能使用碰撞检测CD，原因如下：\n由于无线信道的传输条件特殊，信号强度的动态范围非常大。无线网卡上接收的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高。\n即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。\n\n\n802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个碰撞避免CA功能。\n由于不可能避免所有碰撞，并且信道误码率比较高，802.11标准还是用了数据链路层确认机制（SW协议）来保证数据被正确接收。\n802.11的MAC层标准定义了两种不同的媒体接入控制方式：\n分布协调功能DCF\n点协调功能PCF\n\n\n帧间间隔IFS\n802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定事件后才能发送帧，这段时间称为帧间间隔IFS。\n\n\n帧间间隔的长短取决于该站点要发送的帧的类型\n高优先级帧需要等待的时间较短，因此可优先获得发送权\n低优先级帧需要等待时间较长\n\n\n常用的帧间间隔有以下两种\n**短帧间间隔SIFS(28μs)**。最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧等。\nDFC帧间间隔DIFS（128μs），比短帧间间隔长的多，在DCF方式中用来发送数据帧和管理帧。\n\n\n工作原理\n发送前等一段DIFS是为了给优先级更高的帧腾时间。\n以下情况必须使用退避算法\n在发送数据帧之前检测到信道处于忙状态时\n在每一次重传一个数据帧时\n在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。\n\n\n\n\nCSMA/CA的退避算法\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间\n当退避计时器的时间减小到零时，就开始发送数据；\n当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS，继续启动退避计时器。\n\n\n在进行第i次退避时，退避时间在时隙编号中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度），就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减小。当时隙编号达到255（对应第六次退避），就不再增加了。\n每次解冻之前都要等待一段DIFS的时间。\n\n\n\n\nCSMA/CA的信道预约和虚拟载波监听如图：\n源站在发送数据帧之前会先发送一个短的控制帧，称为请求发送RTS，它包括源地址、目的地址以及这次通信（包括相应的确认帧）所需的持续时间。\n若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个相应控制帧，称为允许发送CTS，它也包括这次通信所需的持续时间。\n源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。\n若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。\n除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中，这样就保证了源站和目的站之间的通信不会受到其他站的干扰。\n如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。\n由于RTS帧和CTS帧都很短，发生碰撞的概率、碰撞产生的开销都很小，因此用很小的代价对信道进行预约往往是值得的。。802.11标准规定了3种情况供用户选择：\n使用RTS帧和CTS帧\n不使用RTS帧和CTS帧\n只有当数据帧的长度超过某一数值才使用CTS帧和RTS帧。\n\n\n除了RTS帧和CTS帧会携带通信所需要持续的时间，数据帧也能携带通信所需要持续的时间，这称为802.11的虚拟载波监听机制。\n由于虚拟载波监听机制，站点只要监听到了RTS帧、CTS帧或者数据帧之中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号。因此虚拟载波监听机制可以减少隐蔽站带来的碰撞问题。 \n\n\n\n3.7 MAC地址，IP地址以及ARP协议\nMAC地址是以太网的MAC子层所使用的地址（属于数据链路层首部内容）\nIP地址是TCP/IP体系结构网际层所使用的地址（属于网际层首部内容）\nARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP可以通过该IP地址获取到该设备的MAC地址。（属于网际层）\n由于这三者关系比较紧密，所以一般放在一起讨论。\n\nMAC地址\n当多个主机连接在同一个广播信道上时，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的表示，即一个数据链路层地址。\n在每个主机发送的帧中必须携带标识发送主机和接收主机的地址，由于这类地址适用于媒体接入控制MAC(Media Access Control)，因此这类地址被称为MAC地址\nMAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址被称为硬件地址； \nMAC地址有时也被称为物理地址（并不意味着MAC地址属于物理层）\n\n\n一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有以恶搞全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。eg:四种MAC地址：全球多播，全球单播，本地多播，本地单播\n多播指的是多播组，即在该组内的都会接收该帧。单播即只有一个接收端。广播即是所有端都接收该帧。\n\n\n如果是单播，那么就在目的地址字段就会填入对应目的端的MAC地址。\n如果是多播，那么就在目的地址字段填入多播MAC组的地址。\n如果是广播，就填入十六进制的全F。 \n\n\n\nIP地址\nIP地址是因特网上的主机和路由器所使用的地址，用于标识两部分的信息：\n网络编号：标识因特网上数以百万计的网络\n主机编号：标识同一网络上不同主机（或路由器各接口）\n\n\n很显然，之前介绍的MAC地址不具备区分不同网络的功能。\n如果只是一个单独的网络，不接入因特网，可以只使用MAC地址。\n如果要接入因特网，则IP地址和MAC地址都需要使用。\n\n\n数据包转发过程中IP地址和MAC地址的变化情况：\n数据包转发过程中源IP地址和目的IP地址保持不变。\n数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变\n\n\n\nAPR协议\n源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送；若找不到，则发送ARP请求（封装在广播MAC帧中）\n目的主机在收到ARP请求后，将源主机的IP地址和MAC地址记录到自己的ARP告诉缓存表中，然后给源主机发送ARP响应（封装在单播MAC帧中）。ARP响应中包含有目的主机的IP地址和MAC地址。\n源主机收到ARP响应后，将目的主机的IP地址和MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机。\nAPR的作用范围：逐段链路或逐个网络使用\n除ARP请求和响应外，ARP还有其他类型的报文（如检查IP地址冲突的“无故ARP、免费ARP”）\nARP没有安全验证机制，存在ARP欺骗（攻击）问题。\n\n3.8 集线器与交换机的区别\n早期总线型以太网使用同轴电缆，后来演进成使用双绞线和集线器HUB的星型以太网。\n使用集线器的以太网在逻辑上仍然是一个总线网（虽然是星型以太网），各站共享总线资源，使用的还是CSMA/CD协议。在逻辑上共享总线，只能工作在半双工模式。\n集线器只工作在物理层，其每个接口仅简单地转发比特，不进行碰撞检测。（由各站的网卡检测）。\n集线器一般都有少量的容错能力和网络管理功能。\n使用集线器HUB在物理层扩展以太网：通过一个集线器HUB将其余的集线器HUB互联起来。如：\n 以太网交换机通常有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在全双工模式。\n 以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）\n 以太网交换机工作在数据链路层（也包括物理层），它受到帧后，在帧交换表中查找帧的目的MAC地址所对应-的接口号。然后通过该接口转发帧。\n 以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。\n帧的两种转发方式\n 存储转发\n 直通交换。采用基于硬件的交叉矩阵。即收到了之后直接转发，这样交换时延很小，但是不进行差错检测。\n\n\n总结如下：\n\n3.9 以太网交换机自学习和转发帧的流程\n以太网交换机工作在数据链路层（包括物理层）\n以太网交换机收到帧之后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过接口转发帧\n 以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。\n 以太网交换机自学习和转发帧的流程：\n收到帧之后进行登记。登记的内容为帧的源MAC地址及进入交换机的接口号；\n根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下三种情况：\n明确转发：交换机知道应当从哪个（或哪些）接口转发该帧（单播，多播，广播）\n盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）\n明确丢弃：交换机知道不应该转发该帧，将其丢弃。（譬如当接收接口和目的接口一致时）\n\n\n帧交换表的每条记录都有自己的有效时间，到期删除，原因如下：\n交换机的接口改接了另一台主机\n主机更换了网卡。 \n\n\n\n3.10 以太网交换机的生成树协议STP\n添加冗余链路可以提高以太网的可靠性（如ABC，冗余链路就是在A和C之间加一条链路）\n但冗余链路会导致形成网络环路\n网络环路会带来以下问题\n广播风暴。大量消耗网络资源，使得网络无法正常转发其他数据帧。\n主机会收到重复的广播帧。大量消耗主机资源\n交换机的帧交换表震荡（漂移）\n\n\n以太网交换机使用生成树STP可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。\n不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）。\n最终生成的树型逻辑拓扑要确保连通整个网络\n当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或者发生故障），交换机都需要进行生成树的重新计算。eg：\n\n\n\n3.11 虚拟局域网VLAN3.11.1 虚拟局域网VLAN概述\n以太网交换机工作在数据链路层（也包括物理层）\n使用一个或多个以太网交换机互联起来的交换式以太网，其所有站点都属于同一个广播域。\n随着交换式以太网规模的扩大，广播域相应扩大\n巨大的广播域会带来弊端\n广播风暴\n难以管理和维护\n潜在的安全问题\n因此应尽量减少广播次数\n\n\n\n\n网络中会频繁出现广播信息\nTCP/IP协议栈中的很多协议都会使用广播\nARP\nRIP\nDHCP\n\n\nNETBEUI\nIPX/SPX\nApple Talk\n\n\n分割广播域的方法\n使用路由器可以隔离广播域（路由器默认情况下不对广播数据包进行转发）。但路由器成本较高，全部使用路由器是不现实的。\n因此VLAN应运而生。\n\n\n虚拟局域网VLAN是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求\n\n3.11.2 虚拟局域网VLAN的实现机制\n交换机实现VLAN要实现两方面的内容：对IEEE 802.1Q帧的处理和对不同交换机的端口类型的处理。\nIEEE 802.1Q帧\nIEEE 802.1Q帧（也称Dot One Q帧），对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记。\nVLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪一个VLAN\nVID的取值范围是\n0和4095都不用来标识VLAN，因此用于标识VLAN的VID有效取值范围为\n\n\n802.1Q帧是由交换机来处理的，而不是由用户主机来处理的\n当交换机收到普通的以太网帧，会将其插入4字节的VALN标记转变成802.1Q帧，简称“打标签”\n当交换机转发802.1Q帧时，可能会删除其4字节的VLAN标记转变为普通以太网帧，简称“去标签”\n\n\n\n\n交换机的端口类型\nAccess\nTrunk\nHybrid\n\n\n交换机各端口的缺省VLAN ID\n在思科交换机上称为Native VLAN，即本征交换机\n在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID\n\n\nAccess端口\nAccess端口一般用于连接用户计算机\nAccess端口只能属于一个VLAN\nAccess端口的PVID值与端口所属VALN的ID相同（默认为1）\nAccess端口接收处理方法\n一般只接受“未打标签”的普通以太网帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节的VLAN标记字段，字段中的VID取值与端口的PVID取值相等。\n\n\nAccess端口发送处理方法\n若帧中的VID与端口的PVID相等，则“去标签”并转发该帧，否则不转发。\n\n\n\n\nTrunk端口\nTrunk端口一般用于交换机之间或交换机和路由器之间的互连。\nTrunk端口可以属于多个VLAN\n用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1\nTrunk端口发送处理方法：\n对VID等于PVID的帧，“去标签”再转发\n对VID不等于PVID的帧，直接转发\n\n\nTrunk端口接收处理方法\n接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节的VLAN标记字段，字段中的VID取值与端口的PVID值相等。\n接收“已打标签”的帧。\n\n\n\n\nHybrid端口\nHybrid端口既可用于交换机之间或交换机与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）\nHybrid端口可以属于多个VLAN（同Trunk端口）\n用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（同Trunk）\nHybrid端口发送处理方法（与Trunk端口不同）查看帧的VID是否在端口的“去标签”列表中\n若存在，则“去标签”后再转发\n若不存在，则直接转发\n\n\nHybrid端口接收处理方法（同Trunk端口）\n接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节的VLAN标记字段，字段中的VID值与端口的PVID值相等。\n接收“已打标签的帧”\n\n\n\n\n\n","tags":["计网"]},{"title":"煮沸的水","url":"/2021/12/24/water/","content":"\r\n  dac5808b672f9c0180c0a1d02013949c98910c3f96fa38a24558c260c807c8e52a695520636567cc9fffe9d41f32306375c9327f54eb2b1130a0116c002fab7e1581189e37370ec993bbf89f474a86418ad50f09cfcf2e8624c3fc15186749a122e6413579c7ff27711f723a6af5352a893f2e2d5647c0c166f97ae34c99c60628f28eaa444b4c654b7a88361c596971535ff007e011f6185d7a4b21385882f2905bcaa0af0b2a956cc9f00ac361e981d02e49062421b9f7f8e6126e0ce4364f7f97f3e175ee4e3e7e5024d06953ee831ad99c0345cfd7fb1ad191a4f08d1bc58fc47bf3e43012af20e523a495e9ff9db9e0ddd94bbfe8ec8b51763125d70ce76bffc751f30fb3c84284cdba3f4002664681afc216643b18cb5dbe39b49903e87e41acd780dc99f3a9dbe284d5f5e720ee64e88f2bdf8d9d26c329e4ea72626e81a1f3b0f91bdd8d7942eda39682dbf094be65e26d3d0d4ec5a40c536d28837708bc3249f92ffbd2ca9e23ae6f9aa7b97eb007c53b47ca87959f065bebaafe286ce410bbc5700ee6bc67929788a496de6201694c4319781232a8eb14305a0ba214ed341313d0d18d67ea17524ce883bde150c79a4ffed395e207362278d64c07d47a8a60ad997e33ede0d5399975563f92456dd0594ae3b84b696e461d8ed918c16361962fd97d3dfd414a6463cdf2e661b97c9c94208d73a7d768b3c5932fd3656b51e902764b6d36bc250b4b9963baea24e1f3b51f46da44a375e139b638a21b401db51248b5b0decffa5ad382badf243bbb6f749f32d67698ed7b0d506559525a383087e7aaaacef69a2d95181cec1611c091715cc8eaab9fa12277a5900453075134862d8f455f7611b82a85c3834f5c3afff755726e40778521e0abd9b2bb67bc673d2206ab2c018ba85991c2a3\r\n  \r\n    \r\n      \r\n      \r\n        冰层撕裂\r\n      \r\n    \r\n  \r\n\r\n","tags":["杂谈"]},{"title":"极限马原速通","url":"/2021/12/18/godknow/","content":"我的评价是一夜速通fuck the lesson.\n导论什么是马克思主义（构成，基本立场，基本观点，基本方法）\n马克思主义构成：马克思主义哲学，马克思主义经济学，科学社会主义\n马克思主义基本立场：无产阶级的解放和人民的解放为己任，以人的全面发展为美好目标，以人民为中心，一切依靠人民，一切为了人民。\n基本观点：对自然，人类，社会思维发展的一般规律的科学认识，是人类思想成果和社会实践经验的科学总结。\n基本方法：唯物辩证主义，历史唯物主义的基础上指导改造世界的方法，如实事求是，辩证分析等马克思主义的创立\n马克思恩格斯的时代，资本主义生产方式有了很大发展。（经济社会基础）\n无产阶级反抗资产阶级中需要科学理论的指导。（阶级基础）\n德国古典哲学，英国古典经济学，英法空想社会主义。（思想基础）\n\n共产主义者同盟是世界上第一个无产阶级政党\n马克思主义著作及有关意义\n德意志意识形态：首次系统阐述历史唯物主义的基本观点\n共产党宣言：无产阶级的第一个党纲\n资本论：阐述了剩余价值学说\n法兰西内战：科学总结了巴黎公社的历史经验\n哥达批判纲领：进一步丰富了社会主义学说\n反杜林论：全面阐述了马克思主义理论体系\n\n马克思主义的鲜明特征\n科学性（独有）\n人民性\n实践性（独有）\n发展性\n\n第一章 唯物论和唯物辩证法第一节 唯物论物质范畴和存在方式\n哲学基本问题：思维和存在的关系问题：\n\n存在和思维的第一性（区分唯心主义和唯物主义）\n存在和思维的同一性（区分主观唯心主义和客观唯心主义）\n\n\n哲学的物质范畴：用于区分古代朴素唯物主义，近代形而上唯物主义和辩证唯物主义\n\n古代朴素唯物主义：世界的本源是一种或几种物质\n现代形而上学唯物主义：物质等同于原子\n辩证唯物主义：物质是一切的客观存在\n\n\n列宁对物质的定义：通过人的感觉而感知，不依赖于人的感觉而存在，可以被人的感觉所复写，摄影，反映\n\n物质的唯一特性：客观实在性\n\n马克思主义物质范畴的理论意义（四点）\n\n坚持了唯物主义一元论，和唯心主义一元路论及二元论划清了界限\n坚持了能动的反映论和可知论，批判了不可知论\n体现了唯物论和辩证法的相统一，克服了形而上学的缺陷\n体现了唯物主义自然观和唯物主义历史观的统一，为彻底的唯物主义奠定了基础\n\n\n物质的根本属性/存在方式：运动\n\n物质和运动不可分割。运动是物质的运动，物质是运动的物质。\n\n\n相对静止：相对位置不变，根本性质不变\n\n绝对运动和相对静止辩证统一：\n\n区别：一个有条件一个无条件\n联系：相互包含相互渗透\n\n\n时间有一维性，空间有三维性\n\n时空是物质的存在方式，时空和物质不可分割 \n\n意识 物质和意识\n意识的概念\n\n自然界长期发展的产物\n人脑的机能\n客观世界的主观映像（意识的本质）\n\n\n意识的发展阶段\n\n物质的反应特性到低等动物的应激性\n高等动物的感觉和心理\n人类的意识\n\n\n意识的产生发展中劳动起着决定性作用，语言是意识的物质外壳，促进了意识发展\n\n意识与物质对立统一：\n\n区别\n物质是本源，意识是派生\n物质是物质，意识是意识\n物质和意识不可以相互替代\n\n\n联系\n物质可以转化成意识，意识可以转化成物质\n意识派生于物质，依赖于物质，又相互独立\n物质决定意识，意识对物质有反作用\n\n\n\n\n意识的反作用：能动作用\n\n意识具有自觉性，目的性和计划性\n意识具有创造性\n意识可以指导实践改造世界\n意识可以调控人的生理和行为\n\n\n主观能动性和客观规律性的辩证统一\n\n尊重客观规律是发挥主观能动性的前提\n发挥了主观能动性才可以正确认识客观规律\n\n\n正确发挥主观能动性\n\n从实际出发。（前提和条件）\n实践是发挥主观能动性的根本途径\n还需要一定的物质条件和物质手段。\n\n\n意识和人工智能\n\n人类的意识是知情意的统一体，人工智能只是对人类理性的模仿，而不具备情感意志等意识形式\n人类的社会性是人类固有的本质属性，人工智能不可能真正具备人类的社会性\n自然语言是思维的物质外壳和意识的显示形式，人工智能难以完全具备理解自然语言的能力。\n\n\n\n世界的物质统一性世界的统一性在于物质统一性，世界统一于物质\n\n为什么是世界是统一于物质的\n自然界统一于物质\n人类社会本质上是物质的\n人的意识统一于物质\n\n\n世界的物质统一性是马克思主义/辩证唯物主义最基本最核心的观点。指导我们在认识世界和改造世界的过程中要从实际出发，实事求是。\n\n第二节 辩证法辩证法的两大总特征是普遍联系和永恒发展\n联系的定义：事物的各要素之间和事物之间相互影响，相互制约，相互作用的关系。\n联系的四个特点\n客观性。\n普遍性。\n任何事物内部都是联系的\n事物不能孤立存在，要与其他食物相联系\n整个世界是相互联系的统一整体\n\n\n多样性。直接联系和间接联系，内部联系和外部联系本质联系和非本质联系，必然联系和偶然联系。\n条件性。\n条件对事物发展和人的活动有支持或者阻碍作用\n条件是可以改变的\n改变和创造条件不是任意的。尊重客观规律反对唯心主义的无条件论和唯条件论，利用有用条件，又善于将不利条件转换成有利条件。\n\n\n\n\n发展的实质：前进的，上升的运动。/新事物的产生和旧事物的灭亡\n新事物为什么不可战胜\n新事物适应新环境\n新事物有新的优点\n新事物受到人民群众的拥护，符合人民群众的利益和要求  \n\n\n\n三大规律之一：对立统一规律\n对立统一规律是辩证法的核心和实质，为什么\n对立统一规律揭示了普遍联系的核心内容和永恒发展的内在动力，从根本上胡嗲了事物为什么会发展的问题\n对立统一规律是贯穿量变质变规律，否定之否定规律以及辩证法基本范畴的中心线索\n对立统一规律提供了人们认识世界改造世界的根本方法——矛盾分析法\n\n\n\n矛盾的同一性和斗争性\n矛盾的基本属性是同一性和斗争性\n矛盾的同一性：矛盾的对立面相互贯通，相互转化的趋势\n矛盾的斗争性：矛盾的对立面相互排斥，相互分离的趋势\n矛盾的同一性和斗争性对立统一\n区别：矛盾的斗争性是无条件的，矛盾的同一性是有条件的\n联系：相互联结，相辅相成\n方法论：看问题要一分为二；求同存异；批判性集成\n\n\n矛盾的同一性的作用：\n同一性是事物存在和发展的前提。\n同一性使得矛盾双方吸收对自己有利的因素，从而得到发展\n同一性规定了事物发展的可能和发展的趋势。事物发展趋势不是随意的，而是有规律地向对立面转化。\n\n\n矛盾的斗争性的作用：\n矛盾双方的斗争促进矛盾双方力量的改变，造成力量不平衡，为对立面的转化，矛盾的质变创造基础\n矛盾双方的斗争是从一种矛盾统一体转化成另一种矛盾统一体的决定性力量。\n\n\n运用矛盾的同一性和斗争性指导实践，还要求正确把握和谐对事物发展的作用  和谐是矛盾的特殊表现形式。和谐体现着矛盾双方相互依存，相互促进，共同发展。并不意味着矛盾的绝对同一，而是相对的，有条件的。\n方法论：实践中将矛盾的同一性和斗争性结合起来，在斗争性中把握同一性，在同一性中把握斗争性\n\n矛盾的普遍性和特殊性\n矛盾的普遍性：矛盾存在于一切食物中，存在于一切事物的发展过程中。共性\n矛盾的特殊性：各个事物的矛盾不同，每一个矛盾在不同的发展阶段特点也不相同。个性。\n矛盾的普遍性和特殊性辩证统一\n区别：普遍性是无条件的，特殊性是有条件的\n联系：任何事物中的矛盾都是个性和共性的有机统一。没有离开个性的共性也没有离开共性的个性。\n\n\n方法论：普遍性和特殊性的辩证统一是马克思主义基本原理同各国具体实际相结合的哲学基础，中国共产党坚持将马克思基本原理和中国具体实际相结合，推动马克思主义在中国进程中不断取得新的胜利。\n\n主要矛盾和次要矛盾\n主要矛盾：矛盾体系中起决定作用的矛盾，支配地位，起主导作用\n次要矛盾：矛盾体系中起次要作用的矛盾，被支配地位，不起主导作用\n方法论：两点论和重点论\n\n三大规律之一：量变质变规律\n质：事物区别于其他事物的内在规定性\n量：事物的规模，程度，排列顺序等可以用数量关系表示的规定量\n度：保持事物质的稳定性的数量接线\n量变：数量增减，排列顺序变化，体现了事物发展过程的渐进性\n质变：根本性变化，体现了事物发展渐进过程和连续性的中断\n量变和质变的辩证关系\n量变是质变的必要准备\n质变是量变的必然结果\n质变和量变互相渗透\n\n\n方法论：一方面要做好日常工作量变，为重大改变做准备，另一方面当质变来临要抓住机遇。\n\n三大规律之一：否定之否定规律\n肯定因素：维持现存事物存在的因素\n否定因素：促使现存事物灭亡的因素\n否定的深刻内涵：\n否定是事物的自身否定\n否定是事物发展的环节\n否定是新旧事物联系的环节\n辩证否定的实质是扬弃。对旧事物批判继承。\n\n\n事物辩证否定的阶段（一个周期）：肯定——否定——否定之否定\n否定之否定揭示了事物发展的前进行和曲折性\n事物发展的前进性和曲折性的统一\n前进性体现在每一次否定都是质变；每一个周期都是开放的，每一个周期的终点都连接下一个周期的起点\n曲折性体现在回复性，发展中会有停顿甚至倒退。说明了事物不是曲折前进的，而是螺旋上升的。\n\n\n方法论：前途光明，道路曲折\n\n联系和发展的基本环节（五大范畴）\n原因与结果\n必然与偶然\n现象与本质\n可能与现实\n内容与形式除了内容与形式，其他四对都是对立统一，内容与形式是不可分割。所以分析其他四个都按照区别和联系的方式来。区别就是概念不同地位不同，联系就是相互包含相互贯通相互转化。\n\n矛盾分析法的核心要求就是善于分析矛盾的特殊性，具体矛盾具体分析\n第二章 实践与认识第一节 实践与认识科学实践观及其意义\n实践的概念：人能动的改造世界的社会物质活动\n科学实践观的意义（四点）：\n克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础。\n建立了科学的，能动的，革命的反映论，实现了人类认识史上的变革\n人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础\n为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法\n\n\n\n实践的本质和基本结构实践是人类社会生活的本质\n\n实践的基本特征\n客观实在性\n自觉能动性\n社会历史性\n\n\n实践的基本要素和基本结构\n基本要素\n主体：不是所有人的都是实践主体，要具备主体能力才行\n中介：分为工具和语言\n客体：不是所有物质世界都是客体，得是被实践活动所指向的对象\n\n\n基本结构：实践的基本要素构成了实践的基本结构\n\n\n实践主体和客体的相互关系\n实践关系（最根本的关系）\n价值关系\n认识关系\n\n\n实践的种类\n物质生产活动\n社会政治活动\n科学文化活动\n\n\n实践对认识的决定作用\n实践是认识的来源（最重要）\n实践是认识的目的\n实践是认识的动力\n实践是检验真理的唯一标准\n\n\n\n认识的本质和过程\n认识路线：唯物主义认识路线，唯心主义认识路线\n\n辩证唯物主义认识论超越旧唯物主义认识论：继承了旧唯物主义的合理前提，即认识是主体对客体的反映，又克服了其离开实践，离开辩证法的问题，坚持科学实践观。\n\n唯物辩证主义认识论两个突出特点：\n\n把实践观点引入了认识论\n把辩证法应用于反映论考察认识的发展过程。\n\n\n认识的本质：在实践的基础上，主体对客体的能动反映\n\n认识的反应特性是认识的基本规定性\n认识的能动反映具有创造性\n\n\n认识的反映特性和创造特性不可分割\n\n创造需要反映作为基础\n反映是在创造的基础上反映\n\n\n认识的过程\n\n从实践到认识，表现为感性认识到理性认识的飞跃\n从认识到实践。更为重要的飞跃。\n\n\n感性认识：关于事物现象，外部联系，各个方面的认识，包括感觉知觉表现三种形式，特点是直接具体\n\n理性认识：对事物的本质，内在联系，自身规律的认识，概念判断推理，间接抽象\n\n感性认识和理性认识辩证统一\n\n感性认识可以深化为理性认识\n理性认识依赖于感性认识\n二者相互渗透\n\n\n从感性认识到理性认识的条件\n\n投身实践获得大量感性材料，这是基础\n在思考的作用下加工感性材料\n\n\n批判极端\n\n夸大理性：教条主义\n夸大感性：经验主义\n\n\n为什么第二次飞跃更重要\n\n认识世界的目的是改造世界\n认识的真理性只有在实践中才能检验\n\n\n实践和认识的辨证运动：实践认识实践，这个过程循环。具有完成了和没完成两个特点。\n\n辩证运动规律：反复性，无限性\n\n\n真理和价值真理的客观性，相对性，绝对性\n真理的定义：标志主客观相符合的哲学范畴，是对客观事物及其规律的正确反映\n真理的特点：\n客观性\n相对性\n绝对性\n\n\n真理的客观性（真理的本质属性）：\n内容是客观的\n标准是客观的\n\n\n真理的客观性决定了真理的一元性，即同一条件下对认识客体的真理性认识只有一个\n真理的绝对性：主客观同一绝对确定，发展的无限性绝对确定（绝对正确）\n真理的相对性：\n世界整体来看，真理只是对一部分事物的反应\n特定事物来说，真理也是对事物一定方面，一定程度，一定层次的认识。\n\n\n真理相对性和绝对性辩证统一：\n相互依存。相互包含。\n人类永远在从真理相对性走向真理绝对性。真理的认识都是从相对性转化为绝对性的环节。\n\n\n\n真理的检验标准\n实践标准的确定性和不确定性\n确定性，绝对性\n是唯一标准\n不可推翻\n现在不能检验，以后也可以检验\n\n\n不确定性，相对性\n受到主客观条件限制，不能完全证实和驳倒一切\n实践的历史性让其只能总体上证实客观事物是否符合，不能一劳永逸永远确证。（检验过了的还要经受检验）\n\n\n\n\n\n真理与价值的辩证统一\n价值：价值是实践基础上实现的主体和客体之间的意义关系，客体对个人，群体，社会所具备的积极意义。\n价值的特点：\n主体性\n多维性\n客观性\n历史性\n\n\n价值评价：对客观价值关系的主观反映\n特点\n以主客体的价值关系作为认知对象\n评价结果与主体直接相关\n评价结果结果正确与否依赖于对客体和主体关系的认识程度\n有科学和非科学之分\n\n\n\n\n真理与价值在实践中辨证统一：\n脱离了真理，价值就偏离了正确轨道\n脱离了价值，真理就没有了主体意义。\n\n\n\n第三节 认识世界和改造世界\n认识世界和改造世界的辩证统一\n认识世界有助于改造世界，正确认识世界是有效改造世界的前提\n改造世界可以更好的认识世界\n\n\n自由的条件\n认识条件。认识越多，行动越主动，自由程度越大\n实践条件。获得的认识用于实践，实现改造世界的目的，才是真正的自由。\n\n\n认识必然和争取自由，是人类认识世界和改造世界的根本目标\n\n第三章 人类社会及其发展规律社会存在和社会意识\n两种历史观：唯心史观和唯物史观\n社会存在的因素\n自然地理环境\n人口因素\n生产方式（决定性）\n\n\n物质生产方式对人类发展的作用\n物质生产活动及生产方式是人类社会赖以存在和发展的基础\n物质生产活动和生产方式决定了社会的结构性质和面貌。决定了人们的经济生活政治生活和精神生活\n物质生产活动和生产方式的变化发展决定整个社会历史的变化发展。\n\n\n社会存在决定社会意识\n社会存在是社会意识的客观来源\n社会意识是社会物质交往的产物\n社会存在发展，社会意识或早或晚发生变化\n\n\n社会意识的相对独立\n社会意识和社会存在之间有不完全同步性和不平衡性\n社会意识内部的各种形式之间相互影响，具有历史继承性\n社会意识对社会存在有反作用，是突出表现\n\n\n文化的对社会发展的重要作用\n思想保证\n凝聚力量\n智力支持\n精神动力社会基本矛盾\n\n\n社会基本矛盾：生产力与生产关系的矛盾，经济基础和上层建筑的矛盾。\n生产力：人们在生产实践中影响改造自然的物质力量\n生产力=劳动者+劳动资料+劳动对象=劳动者+生产资料\n生产工具是区分社会经济时代的客观根据\n生产关系：人们在物质生产过程中形成的不以人的意志为转移的经济关系\n生产关系的内容\n生产资料所有制\n生产中人与人的关系\n产品分配关系\n\n\n生产资料所有制是区分不同生产方式，判定社会经济结构性质的客观依据\n生产力和生产关系不可分割，生产力是物质内容，生产关系是社会形式\n生产力决定生产关系\n生产力的状况决定生产关系的性质\n生产力的发展决定生产关系的变化。\n\n\n生产关系的反作用\n生产关系适合生产力发展客观要求，起推动作用\n不适合起阻碍作用\n\n\n生产力和生产关系的矛盾的运动规律生产关系一定要适应生产力状况，这个矛盾运动的本质联系。围绕这一点，生产关系对于生产力，总是从基本适合到不适合，然后再发展到基本适合的过程；生产关系也从相对稳定到不稳定，最后发展到稳定。这种矛盾运动就推动了社会生产发展。\n经济基础：社会发展到一定阶段的生产力所决定的生产关系的总和\n上层建筑：建立在一定经济基础上的意识形态和与之相适应的制度，组织和设施。\n**国体是社会阶级在国家中的地位，政体是阶级统治的\n具体的组织形式**\n经济基础上层建筑的关系\n经济基础决定上层建筑\n上层建筑反作用于经济基础\n经济基础和上层建筑构成矛盾运动\n决定了上层建筑和适应经济基础第四章 资本主义的本质和规律\n\n\n\n第一节 商品经济和价值规律商品经济形成和发展\n自然经济的概念  满足生产者个人需要而不是为了交换\n商品经济的概念  交换为目的进行生产的经济形势\n商品经济的社会历史条件 \n社会分工 \n生产资料和劳动产品属于不同所有者\n\n\n\n\n商品二因素  \n使用价值（自然属性）满足人的某种需要的有用性。\n价值（社会属性）交换价值的基础，交换价值是价值的表现形式\n使用价值和价值对立统一：对立排斥和统一性。\n\n\n劳动二重性\n具体劳动具体的劳动行为\n抽象劳动劳动耗费的脑力体力。\n具体劳动和抽象劳动对立统一：区别（反映劳动的不同方面）和统一\n\n\n\n\n商品价值的质和量\n\n质指的是价值的实体是什么\n量是社会必要劳动时间\n\n\n社会必要劳动时间和劳动生产率\n\n简单劳动和复杂劳动\n\n\n\n商品价值形式的发展阶段\n偶然价值形式\n扩大价值形式\n一般价值形式\n货币价值形式\n\n\n货币\n概念：一般等价物货币的作用：\n价值尺度\n流通手段\n贮藏手段\n支付手段\n世界货币\n\n\n\n价值规律及作用\n价值规律\n内容\n价值量由社会必要劳动时间决定\n价值量是商品交换的基础，等价交换\n\n\n作用\n调节生产资料和劳动力在各部门之间的比例\n刺激生产力的发展\n调节社会收入\n\n\n局限性（负面）\n调控生产资料和劳动力滞后性，导致一些部门过多\n贫富差距加大\n垄断限制生产力的发展\n\n\n\n\n\n私有制为基础的商品经济的基本矛盾\n以私有制为基础的商品经济的基本矛盾私人劳动和社会劳动之间的矛盾为什么：\n决定了商品经济的本质和发展过程\n是商品经济中一切其他矛盾的基础\n决定了产品生产者的命运在资本主义制度下，商品经济的基本矛盾会演变成资本主义的基本矛盾：生产社会化和生产资料资本主义私人占有之间的矛盾。\n\n\n\n科学认识马克思劳动价值论深化对马克思主义劳动价值论的认识：\n\n深化对创造价值的劳动的认识。\n深化对科技人员，管理人员在价值创造中所起作用的认识\n深化对价值创造和价值分配之间关系的认识\n\n第二节 资本主义经济制度的本质资本主义经济制度的产生\n资本主义产生的途径\n从小商品经济中分化出来\n从商人和高利贷者中转化而来\n\n\n\n\n资本的原始积累\n暴力手段剥夺农民土地\n暴力手段掠夺货币财富（国外殖民国内课税）\n\n\n\n劳动力成为商品和货币转化为资本\n劳动力成为商品的基本条件\n劳动者在法律上是自由的，可以支配自己的劳动力\n劳动者没有生产资料来源，不得不出卖劳动力\n\n\n劳动力的价值：\n维持劳动者本人生存生活资料的价值\n维持劳动者亲属生存生活资料的价值\n劳动者接受培训的费用支出\n\n\n劳动力的使用价值：劳动\n劳动力商品的特点：使用价值是价值的源泉，消费过程中创造新的价值，且新的价值比原本价值更大。\n货币变成资本的条件：货币购买的劳动力带来了剩余价值\n\n资本主义所有制资本主义所有制是生产资料归资本家的一种私有制形式。\n\n本质：在等价交换的原则下，无偿占有工人创造的剩余价值。是资本和雇佣劳动之间剥削和被剥削的体现。\n\n生产剩余价值是资本主义生产方式的绝对规律资本主义生产的直接目的和决定性动机就是为了获取更多的剩余价值\n\n资本主义生产过程具有二重性资本主义生产过程的本质是劳动过程和增值过程的统一\n\n生产物质资料的劳动过程\n特点：劳动者的劳动属于资本家，劳动的成果属于资本家\n\n\n生产剩余资料的增值过程剩余价值的生产过程，是资本主义生产过程的主要方面。\n\n\n不变资本和可变资本\n\n不变资本：以生产资料形式存在的资本。（c）\n可变资本：购买劳动力的资本。（v）\n\n\n资本主义商品的价值构成：W=c+v+m（m是剩余价值）\n\n剩余价值生产率m’：m’=m/v=剩余劳动/必要劳动=剩余劳动时间/必要劳动时间\n\n剩余价值生产的两种基本方法\n\n绝对剩余价值\n延长工作时间\n加强工作强度\n\n\n相对剩余价值缩短必要劳动时间而相对延长剩余劳动时间产生的剩余价值\n资本主义初期时绝对剩余价值起作用，随着资本主义发展，相对剩余价值的作用日益突出\n\n\n\n\n生产自动化是资本家获取高额剩余价值的手段，但此时剩余价值的唯一源泉仍旧是雇佣工人的剩余劳动\n\n资本积累剩余价值资本化就是资本积累本质是不断无偿占有剩余价值来扩大资本规模，进一步扩大加强对工人的剥削和统治\n\n资本主义简单再生产：实质是物质资料再生产和生产关系再生产的统一\n资本主义扩大再生产\n源泉是资本积累\n结果是进一步扩大了资本规模，进一步扩大加强了对工人的剥削统治。\n\n\n资本积累的规模因素：\n剥削程度\n劳动生产率\n所用资本和所费资本的差值\n资本家预付资本大小资本积累不仅是财富占有两极分化的原因，也是资本主义社会失业现象产生根源\n\n\n\n\n\n\n资本的构成\n\n技术构成：生产资料和劳动力的比例\n价值构成：不变资本和可变资本的比例\n\n\n资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利\n\n一方面，生产社会化\n一方面，社会资料资本主义个人占有两方面有深刻矛盾。这是资本主义的基本矛盾。\n\n\n资本的循环周转三个阶段，对应的产业资本的职能：\n\n购买阶段。货币资本。\n生产阶段。生产资本。\n售卖阶段。商品资本。资本周转的前提条件：\n空间上三个阶段并存。\n时间上三个阶段继起。影响资本周转快慢的条件：\n资本周转需要的时间\n生产资本中的固定资本和流动资本的构成。\n\n\n社会再生产连续不断的社会重复生产。\n\n核心问题：社会总产品的实现问题。\n卖东西拿不拿得到钱，原料有没有补充\n\n\n\n\n社会生产的两大部类：\n\n生产生产资料的部类\n生产生活资料的部类消费资料和生产资料要满足两大部类的需求和扩展需求以及结构比例，社会再生产才可以顺利进行。\n\n\n工资工资表现为劳动力的价值和价格，这是资本主义工资的本质。工资表现为”劳动的价格“或者工人全部劳动的报酬，模糊了工人必要劳动和剩余劳动之间的界限，掩盖了资本主义的剥削关系。\n\n\n资本主义的基本矛盾和经济危机\n经济危机的本质特征：生产过剩。\n\n相对过剩\n\n\n资本主义的基本矛盾：生产资料资本主义私人占有和生产社会化之间的矛盾。这是生产力和生产关系的矛盾在资本主义社会的具体体现。\n\n经济危机产生的根本原因/资本主义基本矛盾的体现：\n\n生产无限扩大的趋势和人民需求相对缩小之间的矛盾\n个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。\n\n\n经济危机具有周期性（由资本主义基本矛盾的阶段性决定）\n\n经济危机的四个阶段：\n\n危机\n萧条\n复苏\n高涨\n\n\n\n第三节 资本主义政治制度和意识形态资本主义政治制度及其本质\n资本主义国家的职能：服务于资本主义制度和资产阶级利益作为根本内容。\n\n对内职能：政治统治职能和社会管理职能。\n对外职能：进行国际交往和维护国家安全利益。\n\n\n宪法是资本主义国家制度的核心。\n\n资本主义法律制度的基本原则\n\n私有制原则。法律体系的支柱。\n主权在民原则\n分权制衡原则\n人权原则\n\n\n资本主义政治制度的进步作用（曾经）\n\n战胜封建社会生产方式，保护促进资本主义生产方式起到重要作用\n人们享有了比封建社会更多的自由和发展，促进了人类进步\n积累了丰富的政治统治经验和社会管理经验\n\n\n资本主义政治制度的局限性（现在）\n\n资本主义的民主是金钱操纵下的民主，实际上是资产阶级精英统治的民主。\n法律名义的平等掩盖了事实上的不平等\n政党制是维护资产阶级统治的政治制度。\n政党斗争掣肘，决策效率低下，激化社会矛盾。\n\n\n资本主义意识形态的本质\n\n是资本主义社会的观念上层建筑，是为资本主义经济基础服务的。\n是资产阶级意识的集中体现。\n对于意识形态要辩证看待,过去有进步作用,有积极作用的部分,现在要批判摈弃局限性.\n\n\n\n\n\n第五章 资本主义的发展及其趋势第一节 垄断资本主义的形成和产生资本主义从自由竞争到垄断\n资本主义的发展阶段:自由竞争资本主义和垄断资本主义\n\n垄断资本主义的两个阶段:\n私人垄断资本主义\n国家垄断资本主义\n\n\n\n\n垄断形成的基础(方式),垄断的产生\n\n生产集中:生产资料,劳动力和商品日益集中于少数大企业.\n资本集中:大资本吞并小资本,小资本联合成大资本.\n\n\n垄断的概念:指少数资本主义大企业,为了高额利润联合起来对一个或几个部门的商品和价格进行操纵.\n\n垄断的原因:\n\n获取高额利润\n企业规模大,产生对竞争的限制\n避免两败俱伤\n\n\n**垄断的本质:**通过联合来操纵商品生产和销售市场,操纵垄断价格来获得高额垄断利润\n\n垄断资本主义阶段存在竞争的主要原因:\n\n没有消除产生竞争的经济条件\n竞争是商品经济的一般规律\n\n\n垄断必须通过竞争来进步,攫取更多利益.\n社会生产复杂多样,没有垄断组织可以囊括一切部门和一切生产.\n一方面未被垄断的部门行业有竞争,另一方面垄断集团之间也有竞争.\n\n\n\n\n垄断条件下的竞争的新特点(和自由竞争相比较)\n\n竞争目的变为攫取高额利润,巩固扩大垄断地位\n不仅采用经济手段,还采用非经济的手段,使竞争复杂化\n竞争规模扩大,涉及更多领域,从国内也延展到了国外.\n\n\n金融资本:工业垄断资本和银行垄断资本的结合.\n\n银行垄断资本和工业垄断资本的联系\n金融联系.(贷款)\n资本参与.(股份)\n人事参与.(财务总监)\n\n\n\n\n金融寡头:操纵国民经济命脉,并在实际上控制国家政权的少数垄断资本家或垄断资本家集团.\n\n金融寡头操纵国家的方式\n经济上:”参与制”\n股份参与\n\n\n政治上:”个人联合”\n送人进政府;收买高官;聘请高官\n\n\n其他方面:政策咨询机构,新闻科教等影响内政外交和社会生活的.\n\n\n\n\n垄断利润:凭借垄断地位获得的超过平均利润的高额利润.\n\n垄断利润的来源:归根到底来自于无产阶级和其他劳动人民创造的剩余价值具体有:\n\n对本国无产阶级和其他劳动人民剥削的加强\n通过控制市场占有其他企业尤其是非垄断企业的利润\n通过加强对其他国家劳动人民的剥削和掠夺获取的国外利润\n利用资本主义国家政权实现垄断资本再分配.\n\n\n垄断利润的实现:垄断价格\n\n垄断低价:收生产资料的价格低于生产价格的价格\n垄断高价:卖商品时的价格高于生产价格的价格垄断价格的产生没有否定价值规律,而是价值规律在垄断资本主义时期的表现形式.\n\n\n\n垄断资本主义的发展\n国家垄断资本主义:国家政权和私人垄断资本融合形成的垄断资本主义\n\n国家垄断资本主义形成的原因:\n\n社会生产力的发展,要求资本主义的生产资料在更大范围内被分配.(根本)\n经济波动和经济危机的深化\n缓和社会矛盾,协调利益关系\n\n\n国家垄断资本主义的形式(五种)\n\n国家所有并直接经营的企业\n国家和私人共有合营的企业\n国家通过多种形式参与私人垄断资本的再生产过程\n宏观调节\n微观规制\n\n\n宏观调控的目的:\n\n实现经济快速增长\n充分就业\n物价稳定\n国际收支平衡\n\n\n微观规制的目标:规范市场秩序,限制垄断\n\n微观规制的类型\n\n反垄断法\n公共事业规划\n社会经济规划\n\n\n国家垄断资本的积极作用\n\n国家垄断资本主义一定程度上促进了生产力的发展\n突破了私人垄断资本的狭隘,更适应社会化大生产的要求\n人民生活水平有所改善\n\n\n国家垄断资本的局限性没有根本改变垄断资本主义的性质,没有解决资本主义的基本矛盾,促进生产力的同时也加大了对人民的剥削\n\n国家垄断资本主义的实质\n私人垄断资本利用国家机器为其发展服务的手段\n私人垄断资本为了维护垄断统治和获取高额利润,和国家政权相结合的一种垄断资本主义形式\n是资产阶级国家在直接参与社会资本的再生产过程中,代表资产阶级总利益并凌驾于个别垄断资本之上,对社会经济进行调节的一种形式\n\n\n\n\n金融垄断资本形成和壮大的条件:金融自由化和金融创新.\n\n垄断资本主义的金融化程度提高的表现:\n\n金融业在国民经济中的地位提升\n实体经济部门不得不投入利润一部分到金融领域,导致金融资本急剧膨胀\n制造业就业人数减少,金融为核心的服务业就业人数增加\n虚拟经济越来越脱离实体经济\n\n\n金融垄断资本的两面性:\n\n一方面促进了资本主义经济发展\n另一方面经济过度虚拟化,导致金融危机频发\n\n\n垄断资本向世界范围扩展的经济原因\n\n将国内过剩的资本输出\n将非要害的技术转转移到国外来获取垄断地位\n争夺市场\n确保原材料的稳定来源\n\n\n垄断资本向外扩展的三种形式\n\n借贷资本的输出\n生产资本的输出\n商品资本的输出\n\n\n形式从输出资本来源来看\n\n私人资本的输出\n国家资本的输出\n\n\n垄断资本向外输出是依靠跨国公司这一国际垄断组织形式实现的.跨国公司特点是向外直接投资,在国外建立子公司.\n\n垄断资本扩展的社会经济后果\n\n对于资本输出国:有利\n只有好处.攫取了巨大利润,对发展中国家的的命脉控制等等\n\n\n对于资本输出国:双刃剑\n提供了资金,引进了技术,培训了人员.但消耗了资源,破坏了环境,受到外国资本冲击等等\n\n\n\n\n国际垄断同盟.通过协议在经济上瓜分世界,协议订立和瓜分的结果依据经济实力\n\n第二次世界大战以来,维护国际经济秩序的国际性协调组织:国际货币基金银行,世界银行,世界贸易组织\n\n垄断资本国际化的评价\n\n积极:一定程度促进了经济全球化\n局限:只在一定程度上缓解了局部范围的经济波动,不能对全球性经济波动和危机发挥有效作用.\n\n\n资本主义到垄断资本主义,再到帝国主义的五个基本特征:\n\n垄断组织在经济生活中起决定作用\n在金融资本的基础上形成金融寡头的统治\n资本输出有了特别重要的意义\n瓜分世界的资本家国际垄断同盟已经形成\n最大资本主义列强已经把世界上的领土分割完毕\n\n\n帝国主义的实质:垄断资本凭借垄断地位,获得高额垄断利润.\n\n\n经济全球化及其影响\n经济全球化的表现\n生产全球化\n贸易全球化\n金融全球化\n\n\n经济全球化的原因\n科学技术的进步和生产力的发展(根本原因)\n跨国公司的发展(适宜的企业组织形式)\n各国经济体制的变革和国际经济组织的发展(体制和组织保障)\n\n\n经济全球化的影响\n促进生产社会化的程度不断提高,社会分工在更大范围内进行,带来巨大分工利益.推动世界生产力的发展.\n对发展中国家的积极作用\n经济全球化为发展中国家提供了先进的技术和管理经验\n经济全球化为发展中国家提供了更多就业机会\n经济全球化推动了发展中国家的国际贸易发展\n经济全球化推动发展中国家的跨国公司的发展\n\n\n经济全球化的负面影响\n发达国家和发展中国家的地位收益不平等\n加剧了发展中国家的资源短缺和环境污染\n一定程度上增加了经济上的风险,地区危机可能会引起全球危机面对不同国家在生产水平,发展水平和文化背景方面的差异,要以构建人类命运共同体的理念引领经济全球化.\n\n\n\n\n\n第三节 资本主义的历史地位及发展趋势\n资本主义必然为社会主义所代替\n资本主义的基本矛盾包含着”现代一切冲突的萌芽”.\n资本积累推动了资本主义基本矛盾不断激化并最终否定了资本主义自身\n国家垄断资本主义是资本社会化的更高形式,是社会主义的前奏\n资本主义社会存在着资产阶级和无产阶级两大阶级的矛盾\n\n\n\n","tags":["课程"]},{"title":"深入理解计算机系统","url":"/2021/10/29/csapp/","content":"啥也没整理，鹦鹉学舌，都是书上现有的东西。随便瞟两眼就行，别细看，细看就够得上浪费时间谋害生命。\n第一章 第一章啥也没有，跳了。 也许有点啥，但我白兰。\n第二章\n将的非负整数次幂,即快速转置成十六进制：\n将表示成的形式，转置后的十六进制即为面跟着个十六进制的。\n\n\n\n如，其中，则十六进制表示为(2的三次方跟着2个十六进制的0)\n\n十六进制跟十进制的转换和数字逻辑里一致，不赘述。写在这里是让你回想一下。\n\n防止记不起来还是给一张图\n\n字节这块需要注意的是，32位和64位常用的数据类型中，不同的是long，在32位上是4字节，64位上是8字节。char *也有区别，但考虑的相对较少。\n\n \n\nISO  C99中引入了数据大小固定的数据类型。其中就有int32_t和int64_t，分别为4个字节和8八个字节。\n\n大部分的编译器和机器都认为是有符号数据类型，但实际上C标准不保证这点。所以其实需要程序员声明是有符号的。但实际上这点根本无所谓。\n\n\n大端法和小端法给一个三级标题是因为这个东西是考试重点，后面也一样。\n\n大端法即最高有效字节排列在前面的方式。是符合人类直觉的正常数字排列。Sun是大端法机器。\n\n小端法将最低有效字节排列在前面的方式。linux 32和Windows和Linux 64均为小端法机器。\n\n需要注意的一点是，实际上机器代码中按照大端和小端排列的只有立即数的部分，而表明操作的代码不按照这个来。（图中右侧代码从下往上读）\n\n\n对齐 （PPT上有但我怀疑不用考）\n\n按边界对齐（假定存储字的宽度为32位，按字节编址）（图上）\n\n字地址：4的倍数（低两位为0）\n半字地址：2的倍数（低位为0）\n字节地址：任意\n\n\n不按边界对齐  （图下）坏处：会增加访存次数\n\n关于对齐的样例\nstruct S1{    int i;    char c;    int j;}struct S2{    int i;    int j;    char c;}\n在要求对齐的情况下，结构体S2优于结构体S1。\n\n\n同时考虑对于struct S2 d[4]需要分配几个字节。（数组）\n布尔运算这个布尔运算就是与或非异或同或那一套，数电里有详细说明，这里就不赘述了。提一下。\n\n确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后转换回十六进制\n\n\n注意：要区别和，&amp;和&amp;&amp;，~和！。（这三组中，前者都是算数运算符，后者都是逻辑运算符）注意：|和&amp;的逻辑运算符第二个重要的区别就是如果逻辑运算符中，如果对第一个参数求值可以得到表达式的结果，则不会对第二个参数求值。比如说a&amp;&amp;5/a不会导致被零除，p&amp;&amp;p++也不会访问空指针。\n\n\n掩码运算掩码表示的是一个位模式，即从一个字中选出的位的集合。（就是从一个长串里挑几位出来）。举一个例子，掩码0xFF(最低八位为1，其余为0)表示一个字的低8位字节。令a为一个字，则a&amp;0xFF就表示为a的最低八位。这类操作非常普遍，而且有许多精彩的操作，后续讲例题的时候会提到。\n\n移位运算首先提一点，一个长为位的操作数，最高位表示为，最低位表示为。\n\n左移左移操作均为逻辑左移。x &lt;&lt; k即表示为。同时，移位操作时满足结合律的，x &lt;&lt; k &lt;&lt; j == x &lt;&lt; j &lt;&lt; k移位后得到[]\n\n右移\n\n逻辑右移逻辑右移在左端补个0，x &gt;&gt; k表示。即移位后得到[ ]\n算数右移算数右移在左端补个最高有效位的值。即移位后得到[ ]\n\n\n所有机器对无符号数默认使用逻辑右移，有符号数默认算术右移。\n\nJava中，x &gt;&gt; k表示算术右移k个位置。x &gt;&gt;&gt; k表示逻辑右移k个位置。C中没有这个写法。\n\n移动k位，这里的k很大假设对于一个位的数据类型，如果想移动位，那么会有什么结果呢？\n\n在某些C标准中，会移动mod位，比如说在=32时，移动36位就是移动4位。但这在C程序中并不是一定成立的，所以最好还是让移动位数小于。但这在Java中是一定成立，这在Java中被特别要求。\n\n\n关于移位的运算优先级移位的运算优先级低于加减法。这一点有点反直觉，因此不确定的时候最好都加上括号。\n\n\n有符号数的除以2的幂向右算数右移。有符号数直接右移位，是除以之后向下取整。加上偏置值之后右移位，是除以之后向上取整\n所以表达式计算\nIEEE浮点表示 为啥其他的不说先说这个捏。 因为这个我是真不会。\n\nIEEE浮点标准的形式表示一个浮点数\n是符号位\n是尾数。其范围是到，不一定对应\n的作用是对浮点数加权，这个权重是2的次幂（可能是负数），也不一定对应\n\n然后有两种常见的格式，每种格式中都定死了所占据的位数。分别为float和double。如图：float：一位，八位，二十三位。double：一位，十一位，五十二位。\n根据的值，有以下四种情况\n\n规格化的值此时的位模式不全为1也不全为0。这时要加上偏置值的形式：指的是此时总的符号位，所以单精度时，双精度时\n\n这个偏置值和有符号算数位移的偏置值算法不一样，那个是同时小数点在最高位的左边，也就是说整个都在小数点右边。\n\n\n非规格的值的位全为0的时候，表示的就是非规格的值。这种情况下：\n\n特殊情况：的位全为1\n\n如果全为0，那么表示无穷大，为1是负无穷，为0是负无穷\n如果不是0，那么表示的就不是一个数字。\n\n\n\n以上就是知道的所有知识了。下面的图是个example，用来确定思路用的。爱看不看。\n\n舍入根本没看，完全不懂，以后补上。\n浮点运算实话实说，这一块我是根本没看懂，属于是先记下来，以后再看。\n\n浮点数的加法\n\n不具备结合性。(会导致舍入)比如说（其中是double，是float）\n满足单调性，且这一点是无符号加法和补码加法都不满足的。即如果有浮点数，那么对于任意值的，都有\n\n\n浮点数的乘法\n\n满足可交换性\n不具备结合性\n不具备分配性\n\n\n\n强制转换\n执行一个运算，只要其中有一个数是无符号数，就会把其他数值全部转换为无符号数并进行运算。\n\nsizeof函数返回的值是一个无符号数。\n\n将short转换为unsigned时，我们要先改变其大小，之后再完成从有符号到无符号的转换。\n从int到float，数值不会溢出，但是可能被舍入\n从int或者float到double，可以保留精确的数值\n从float或者double到int，值会向0舍入。同时，也可能会溢出。\n\n第三章 程序的机器级表示***的汇编。\n\n汇编代码中所有以’.’开头的都是指导汇编器和链接器工作的伪指令，也就是说都是可以忽略的废话。就像这种东西：\n\n关于如何用生成Inter格式的汇编代码\n\n\n  &gt;linux&gt; gcc -Og -S -masm=interl xxxx.c（文件名）\n  至于Intel格式和ATT的区别：  \n\n可以在C程序中加入汇编代码来提高效率。但书上提的两种方法我都没看懂。所以不细说了。\n\ngcc和objdump命令  连续考了两年，记一下。\n\ngcc指令：\n\n &gt;linux&gt; gcc -g aa.c -o aa对aa.c生成可执行文件，存储在aa。\n&gt;linux&gt; gcc -c aa.c对aa.c生成可执行文件，并命名该文件为aa.o（可执行文件后缀为o，内容为二进制机器码）\n&gt;linux&gt; gcc -s aa.c对aa.c生成汇编文件，命名该文件为aa.s\n\n\nobjdump生成反汇编指令文件\n\n&gt;linux&gt; objdump -d foo &gt; foo.s对foo（可执行文件）反编译，得到的文件存储在foo.s（汇编文件）\n&gt;linux&gt; objdump -d foo对foo反编译，生成名为foo.s的汇编文件。\n\n\n\n数据格式  这玩意儿经常用，mark一下。  \n  记住bwlq，然后指针和long一致就完事了。\n\n单精度和双精度用的是一组完全不同的指令和寄存器。所以double和int后缀相同并不会导致问题。\n\n\n单精度浮点4个字节，双精度8个字节，X86历史上还有一个long double的浮点形式，十个字节。但是不咋好用，精度低不好移植，用的也少。\n\n通用目的寄存器  背！\n  \n  上面的63，31，之类的标识指的是对应的位长，比如说eax寄存器有32个位，rax就是64个位。借此来访问寄存器的不同位置。\n  低于64位的寄存器不能用来储存地址，比如说%ebx就不能用来储存地址。\n\n把数据从其他位置迁移到寄存器里时，有两条规则。\n1.生成1字节或者2字节数字的指令会保持寄存器剩下字节不变。\n2.生成4字节数字的指令会把高位4个字节置0.\n3.生成8个字节当然就占满了。 （2条规则当然有三点）\n\n\n\n\n注意栈指针%rsp,用来指明运行时栈的结束位置。有些程序会读写这个寄存器。\n\n操作数地址  背！\n  \n  带r的就是寄存器，Imm指的是立即数，M指的是内存。  $Imm的操作数就是Imm。很直观。\n  注意：格式里不存在括号里同时有三个寄存器的模式。这个考了两年。\n数据传送指令  背！\n  其实也不用背。看看就懂了。和上面说的差不多。  movabsq下面会讲。\n  \n\n源操作数可以是一个立即数，可以在寄存器后者内存，目的操作数可以指定到一个位置，一个寄存器或者一个内存地址。\n\n\n注意： x86-64加了条限制，两个操作数不可以都指向内存地址。将一个值从内存移到内存，需要两条指令，一条把值移到寄存器，一条把值从寄存器复制到目的内存。\n\n\n大部分时候，指令只会更新目的操作数指定的寄存器字节或者内存位置。唯一的例外是指令，会把目标寄存器的高位4字节变成0。（这个上面说过了，再说一遍）原因是x86-64采用的牛逼惯例：任何寄存器生成32位值得指令都会把该寄存器得高位部分变成0。\n\n关于和：常规的操作，其如果要以立即数为源操作数，那么这个立即数只能是32位的补码数字，然后把这个数符号扩展成64位。（也就是说不能直接操作64位立即数）。但可以以任意64位立即数值作为源操作数，但是只可以以寄存器作为目的。\n\n将较小源值复制到较大的目的的时候：一般这个时候要考虑位的扩展，所以指令也有零位扩展和符号扩展两种。如下：是零位扩展，是符号扩展。反正就后缀的俩字母，前面的那个是源码格式，后面的那个是目的格式。好记。\n\n\n  \n\n这里没有,也就是没有四位到八位。但实际上这个零扩展操作直接用就可以实现，这依靠于x86的牛逼惯例。经过神的提点，教材里关于上面这句关于的语句并不严谨，实际上和并不等同，只是说类似于 %eax %ebx的操作可以得到 %eax %rbx的效果。，的源操作数和目的操作数仍然受其本身的限制。\n\n  \n\n注意到这里头有个，这个只能以%eax作为源，%rax作为符号扩展的目的，跟 %eax %rax实际上一个意思，但是写起来更短更紧凑。\n\n\n注意：移位指令中，使用符号拓展还是零位拓展取决于源操作数的数据结构，而不是目的操作数的数据结构。\n\n汇编指令纠错\n寄存器和指令后缀不匹配/两个寄存器位数大小不一样\n两个参数都是内存地址\n用非64位的寄存器作为内存地址\n寄存器不存在\n立即数作为目的\n操作数的写法格式有误。如(rax,rbx,rcx)。\n\n压入和弹出栈数据  栈顶元素时所有栈中元素地址中最低的，地址向栈底依次增大。\n\npush指令是压入，pop是弹出，%rsp保存栈顶元素的地址。就很基础，所以放一起说了。\n\n将一个四字值压入栈中，首先需要将栈指针减8，然后将值写到新的栈顶地址。\n\n\n\n所以pushq %rbp（把%rbq的值压入栈）等价于下面两条指令：subq $8,%rspmovq %rbp,(%rsp)\n\n  弹出栈同理\n\npopq %rax等价于下面两条：movq (%rsp),%raxaddq $8,%rsp\n\n  不过pop和push只需要一个字节，执行相同效果的两条指令要八个字节。\n\nx86-64中，栈是向低地址方向增长的，所以压栈要做的是减小%rsp的值，出栈要增加%rsp的值。\n\n算数和逻辑操作  看图\n  \n加载有效地址（lea）   leaq这个指令和mov不同的在于，这条指令不是从指定的位置读入数据，而是将有效地址写入目标操作数。  打个比方，如果%rdx里头的值设为x，而x+8的地址内存储y，那么\nleaq 8(%rdx),%rax\n\n   就是将%rax的值设为x+8，而\nmov 8(%rdx),%rax\n\n   指的是把%rdx+8指向的值存入x，也就是把%rax设为y。\n  注意：lea的目的操作数只能是寄存器\n\n一元操作的操作数可以是寄存器/内存。二元操作的操作数可以时立即数/寄存器/内存，目的操作数可以是寄存器/内存。\n\n移位操作\nSAL和SHL差不多，都是左移然后在右边补零。但SHR和SAR不一样,SHR是逻辑右移，SAR是运算右移（按照最高位的值来补位）。\n\n移位操作的移位量要么是一个立即数，要么是单字节寄存器%cl中的值（只能是这一个寄存器）。但以%cl作为移位量时，实际的移位量会根据移位指令的数据格式从%cl中取数，由%cl中的低m位决定（二进制），这里，而更高位会被忽略，举一个例子：\n\n当%cl中的十六进制值为0xff时，指令salb会移7位，sabw会移15位，sall会移动31位，salq会移动63位。（反正不能超过对应数据格式的最多位数）同时salb只看%cl中二进制的最低3位，salw只看最低4位，依次递推。\n\n\n\n特殊的算数操作  这块其实讲的就是怎么在64的情况下得到128位的乘积。  但好像不考。先跳了。    这几条指令中提供的为立即数。  %rdx存储高64位，%rax存储低64位。\n  如果是除法，那么除完之后的商放在%rax，余数存储在%rdx。\n  指令clto可以把%rax的符号位复制到%rdx的所有位。这条指令不需要操作数。\n条件码\nCF：进位标志。最近的操作使最高位产生了进位或者借位。用来检查无符号位的溢出。\nZF：零标志。最近的操作得到的结果是0.\nSF：符号标志。最近的操作得到的结果是负数。\nOF：溢出标志。最近的操作导致一个补码——正溢出或者负溢出都行。\n\nlea指令和mov指令都不改变条件码。\ntest指令的运算规则和ADD一样，唯一的区别是test不会更改目的操作数里的值。\n\ntest的典型用法：\n两个操作数是一样的，用来检查是正数，负数，还是0.\n其中一个操作数是掩码，用来指示哪些位应该被测试。\n\n\n\n访问条件码set指令的目的操作数是低位单字节寄存器元素之一（如al），或是一个字节大小的内存地址。以此时的标志码为根据，将这个字节设为0或者1.set指令的作用可以根据后缀与cmp指令连用来理解。如：\ncmp %rbx %rcx sete %al\n就是在%rbx与%rcx储存值相等时，将%al的值设为1.注意这里的后缀l和b指的不是操作数的大小。注意有符号和无符号用的后缀是不同的：\n\n无符号的大于后缀是a，小于后缀是b（below）\n有符号的大于后缀是g（greater），小于后缀是l（less）\n\n跳转指令\n\njmp指令作为无条件跳转，可以是直接跳转或者是间接跳转。\n直接跳转就是直接跟一个地址立即数。\n间接跳转：如 jmp *%rax就是以%rax中的值作为跳转目标。\n\n\n\n其余的所有条件跳转只能是直接跳转条件跳转的后缀命名规则和set指令一致，不赘述了。\n\n跳转指令的机器编码先不写，这一块书上写的很迷惑。\n\n条件传送指令源是寄存器/内存，目的只能是寄存器，不支持单字节传送。\n其实这里还有一大堆东西，但总结一下就是教你怎么看懂汇编。白兰不想看，不写。\n栈帧令Q作为被调用的函数，A为调用Q指令的下一条指令的地址。PC计数器中存储下一条将要执行的指令的地址。call Q指令会把地址A压入栈中，并把PC设置为Q的起始地址。压入的地址A是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。如图。call指令也可以是间接的。\n传参时寄存器的对应顺序如图。如果参数超过6个，那么把前六个参数放入寄存器中，剩下的参数传到栈帧，而第七个参数位于栈顶。传参是在call指令之前完成的。通过栈传递参数时，所有的数据大小都向8的倍数看齐。\n根据惯例，寄存器%rbx、%rbp和%r12~%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。\n所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。\n栈中的寄存器（栈帧的简略版）\n\n倒也不用全记，但顺序要记，传进来的参数按顺序都进了哪些寄存器。rdi,rsi,rdx,rcx,r8,r9\n传参只进这六个，多的就用栈帧存。然后还有几个特殊的：rax：存储返回值rsp：指向栈顶rbp：有时候用来指栈底\n然后被谁保存的问题：\n调用者（caller）保存的寄存器：rax,rdi,rsi,rdx,rcx,r8,r9，r10,r11\n被调用者（callee）保存的寄存器：rbx,r12,r13,r14,rbp,rsp\n\n\n\n","tags":["课程"]},{"title":"数据结构","url":"/2021/10/29/structure/","content":" 背概念记算法。 GO！\n绪论 全你妈是概念。 GO不住了，直接寄。 我的评价是直接跳： heye神的数据结构笔记\n1.2 基本概念及术语\n数据：对客观事物的符号表示，计算机科学中指所有能输入到计算机中并被计算机程序处理的符号的总称。\n\n数据元素：数据的基本单位。可以由若干个数据项组成。（类似结构体）\n\n注意：数据元素是数据的基本单位，数据项是数据的最小单位\n\n\n数据对象：性质相同的数据元素的集合。（比如说所有整型或者所有字符）\n\n数据结构：相互之间存在一种或多种特定关系的数据元素的集合。\n\n\n 数据元素之间的相互关系就是结构。 数据结构的形式表达为，其中数据元素上的有限集，是上关系的有限集。 一般有以下几种结构    - 集合：数据元素隶属于同一集合，除此之外没有其他关系    - 线性结构：数据元素存在一个对一个的关系    - 树形结构：数据元素存在一个对多个的关系    - 图状结构或网状结构：数据元素存在多个对多个的关系\n&gt;以上这几种结构还可以称为**逻辑结构**\n\n\n存储/物理结构：数据结构在计算机中的表示（又称映像）\n\n位：计算机中表示信息的最小单位，二进制中的一位。\n元素/结点：用一串位表示的数据元素（整型或者字符一类）\n数据域：数据元素由多个数据项组成，数据域就是对应各个数据项的子位串。\n\n\n顺序映像  顺序存储结构非顺序映像  链式存储结构\n\n数据类型：值的集合和定义在这个值集上的一组操作的总称。（例如整型变量，值集为整数，定义在其上的运算是加减乘除等计算）  按照值的不同，数据类型分成两种：\n\n原子类型：不可再分。（比如说字符整型长整型浮点一类）\n结构类型：结构体或者数组。\n\n\n抽象数据类型（ADT）：是指一个数学模型以及定义在该模型上的一组操作。\n\n和数据类型差不多，但更强调数学层面，而且不再仅限于处理器自己定义的类型如整型一类，囊括了用户自己定义的数据类型\n\n  分为三类：  原子类型，固定聚合类型，可变聚合类型（后面两种可以统称为结构类型）\n  D,S,P：数据对象，数据关系，基本操作。\n\n多形数据类型：是指其值的成分不确定的数据类型。（就是没写明变量是什么类型）\n\n存取结构顺序存储结构的存取结构是随机存取，链式存储结构的存取结构是顺序存取\n\n\n1.4 算法\n五个重要特性：\n\n有穷性：在有穷步内结束，每一步都可以在有穷时间内完成。\n\n确定性：每一条指令都有确切的含义，不会有歧义。任何情况下算法都只有一条路径，对相同输入可以得到相同输出。\n\n可行性：可以用已有的基本运算执行有穷步来实现。\n\n输入：有零个或多个输入。\n\n输出：有一个或多个输出。 \n\n\n\n算法设计的要求：\n\n正确性：程序对于精心选择的典型，苛刻而带有刁难性的几组输入数据能够得出满足规格说明的结果。（答案要对）\n\n可读性：要看得懂\n\n健壮性：输入非法可以察觉，不会被轻易弄崩。\n\n效率和低存储需求（高效性）：效率高，需求存储空间少。\n\n\n\n渐近时间复杂度（时间复杂度）：（基本操作的执行次数根据问题规模记作）\n\n频度 程序中某一语句被执行的次数。\n\n\n\n给个练习：\n\n空间复杂度：\n原地算法：空间复杂度为的算法。\n\n\n\n第四章：串KMP假设串为T\n\n求next数组：1.首先让next[1]=0,next[2]=12.从next[3]开始，假设为next[i]，则比较T[i-1]和T[next[i-1]]是否相等。3.如果相等，那么next[i]=next[i-1]+14.如果不相等，就比较T[next[next[i-1]]]和T[i-1]是否相等，如果相等，那么next[i]=next[next[i-1]]+15.如果还不相等，就比较T[next[next[next[i-1]]]]和T[i-1]是否相等，依次递推。6.依次递推。\n求nextval数组：只讲在next数组的基础上怎么求现在假设已经有了next[n]这个数组。1.首先让nextval[1]=02.从nextval[2]开始，如果T[i]=T[next[i]],那么nextval[i]=nextval[next[i]],如果不相等,那么nextval[i]=next[i]3.依次递推\n\n第五章：数组和广义表\n寻址具体方法看例题。\n\n\n矩阵的压缩存储\n对称矩阵\n\n  下标公式推导：  只讨论的情况。  sa中的排列规则是从开始，对从小到大，列出所有，然后，重复这个过程，直到。  所以在列到第行的时候，sa一共有个元素。等差公式得到共有个元素，又因为sa中元素下标从0开始，所以第的下标为,的下标为。向后一个个加就可以得到的下标为。  和放在同一个位置，所以对调后照样算就是。\n  注意：因为对角线的存在，所以占用空间不是\n\n三角矩阵\n\n  下三角矩阵的下标：  跟对称矩阵的排列规律是一样的，区别就是sa[0]=，所以在对称矩阵下标基础上+1，变成了。  上三角矩阵的下标：  与之前不同，上三角矩阵sa中的排列规则是从开始，对从小到大，列出所有，然后，重复这个过程，直到。即排列为：    所以列到第行的时候，sa一共有个元素，等差公式得到为个元素。因为下标从1开始，所以的下标为,往后递推得到的下标为。\n\n带状矩阵（对角矩阵）第一种，用矩阵存。图里写的很清楚，不赘述了。第二种，用一维数组存。注意首行后和末行前都空了一个元素，这两行的元素是个。主对角线及其两侧共（奇数）条对角线的带状区域————对角矩阵。\n\n随机稀疏矩阵    稀疏矩阵压缩之后，会失去随机存取的功能\n- **三元组表**\n![66.png](https://api2.mubu.com/v3/document_image/b752a570-43e0-4aaa-9cff-39763801def0-14970684.jpg)\n\n- **三元组表的应用：矩阵转置**\n![66.png](https://api2.mubu.com/v3/document_image/d2365e73-725d-4d3a-9045-49f565166a36-14970684.jpg)\n有两种方法，普通转置和快速转置。\n普通转置就是按列对原矩阵进行遍历。由于行数低的会优先出现，所以可以直接按元素在遍历时出现的顺序来行转列，列转行。\n大致算法思路如下图：\n![66.png](https://api2.mubu.com/v3/document_image/2ce62294-a984-4c5e-9957-e056f2990f81-14970684.jpg)\n复杂度$O(n^2)$\n**快速转置法**：\n![66.png](https://api2.mubu.com/v3/document_image/db5d2ada-a489-407d-a816-9cb0290d3591-14970684.jpg)\n大致实现思路：先遍历一遍原矩阵$a$得到num[]，然后通过num[]得到cpot[]（cpot[col]=cpot[col-1]+num[col-1]）。然后再遍历一次原矩阵，这次遍历把每个遍历到的元素直接放到$b$中对应的位置。（利用cpot，每次对应列有一个元素放入，就++cpot[col]，得到该列下一个元素在$b$中的位置）。\n如图：\n![66.png](https://api2.mubu.com/v3/document_image/108e822d-f350-47b5-b52b-adb693b519e9-14970684.jpg)\n复杂度为$O(n)$。\n\n下面这俩不是重点，看看就行。\n- 行逻辑链接的表：\n![66.png](https://api2.mubu.com/v3/document_image/78c62066-49f2-4d4e-9642-ce4be04bf26b-14970684.jpg)\nTriple存的就是所有三元组。\nrpos存的是每行第一个非零元素在矩阵中出现的位置。\n- 十字（正交）链表\n![66.png](https://api2.mubu.com/v3/document_image/645e4b52-63eb-4a72-949d-b558779d4409-14970684.jpg)\n![66.png](https://api2.mubu.com/v3/document_image/a1bef51f-b9f3-4071-86fa-6bb3ead38d95-14970684.jpg)\n在十字链表中插结点，要在行表中插一次，列表中插一次。\n\n广义表  原子：逻辑上不能再分解的元素  子表：作为广义表中元素的广义表    注意：表尾不是指最后一个元素，而是除了第一个元素之外的所有元素。\n\n图形表达方式：圆圈是表，矩形是原子\n\n广义表分类\n纯表：和树型结构对应的广义表\n再入表：允许结点共享的广义表\n递归表：允许递归的广义表线性表纯表再入表递归表\n\n\n广义表的存储结构两种存储结构：\n头尾链表存储typedef enum {ATOM, LIST} ElemTag;// ATOM==0:原子；LIST==1：子表typedef struct GLNode{\tElemTag  tag;\tunion {\t     AtomType  atom;\t     struct  {\t          struct GLNode  *hp, *tp;\t     }ptr;\t}} * GList1;\n在结构体定义里用联合区别了原子和子表，tag用来表明类型。tag=0为原子结点，tag=1为表结点。示例图：\n\n注意：由于原子结点没有后继指针，所以每个原子结点都要搭配一个表结点，这个表结点的hp指向原子结点，tp指向后继。\n扩展的线性链表形式typedef enum {ATOM, LIST} ElemTag;// ATOM==0:原子；LIST==1：子表typedef struct GLNode{\tElemTag  tag;\tunion {\t     AtomType  atom;\t     struct  {           struct GLNode  *hp;      } } struct GLNode  *tp;} * GList2;\n\n与上一种的区别在于这里的原子结点也有后继指针。这一点更符合直觉。示例图：\n*广义表的递归算法\n计算广义表的深度\n方法一：基本项：DEPTH(LS)=1;（LS为空表）DEPTH(LS)=0;（LS为原子）归纳项：DEPTH(LS)=1+max{DEPTH()}int GListDepth(GList1 L){           if  (!L) return 1;   //空表    if  (L-&gt;tag==ATOM) return 0;  //单原子    for (max=0, pp=L; pp; pp=pp-&gt;ptr.tp) {          dep=GListDepth (pp-&gt;ptr.hp);          if (dep&gt;max) max=dep;   }   return  max+1;}//GListDepth\n遍历的是tp，递归访问的是hp。同时因为hp比上一结点的层次低1，所以return是max+1.\n\n注意：max是一个全局变量\n方法二： int GListDepth(GList1 L){            if  (!L) return 1;   //空表    if  (L-&gt;tag==ATOM) return 0;  //单原子    dep1=GListDepth (L-&gt;ptr.hp)+1;    dep2=GListDepth (L-&gt;ptr.tp);    if  (dep1&gt;dep2)  return dep1;    else   return  dep2;}//GListDepth\nhp+1是因为头结点比原结点低一层，而尾结点和原结点同层。\n\n\n复制广义表如果空了就复制NULL；如果是原子就复制单原子；如果是表就分别复制头和尾；Status CopyGList(GList1 &amp;T, GList1 L){        if  (!L) T=NULL;   //复制空表 else {    T=(GList1)malloc(sizeof(GLNode));    if (!T) exit(OVERFLOW);    T-&gt;tag=L-&gt;tag;    if (L-&gt;tag==ATOM) T-&gt;atom=L-&gt;atom; //复制单原子    else {         CopyGList(T-&gt;ptr.hp, L-&gt;ptr.hp);         CopyGList(T-&gt;ptr.tp, L-&gt;ptr.tp);    } } return  OK; }//CopyGList\n\n\n\n\n\n第九章：二叉树\n有n个结点的二叉树的形态数目套公式，有种。\n\n术语：\n\n结点的度：结点拥有的子树数目\n叶子（终端）结点：度为0的结点\n分支（非终端）结点：度不为0的结点\n树的度：树的各结点度的最大值\n内部结点：除根结点之外的分支结点\n双亲与孩子（结点）：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲\n兄弟：属于同一双亲的孩子\n结点的祖先：从根到该结点所经分支上的所有结点\n结点的子孙：该结点为根的子树中的任一结点\n结点的层次：表示该结点在树上的相对位置。根在第一层，其他的结点依次下推，若某结点在第层上，则其孩子在第层上。\n堂兄弟；\n\n\n\n","tags":["课程"]},{"title":"数字逻辑","url":"/2021/10/29/logic/","content":"麻。\n第一章 开关理论基础1.1 二进制系统两种基本的二进制表现波形：电平型和脉冲型\n\n电平型：一般用于数据信号，高低电平表示1/0\n脉冲型：一般用于控制信号，上升沿或者下降沿有效\n\n1.2 数制和码制数制转换\n其他进制转换成十进制：按位权相加即可。\n\n十进制转换成其他进制：整数和小数部分要分别转换\n\n整数部分：比如说十进制整数部分转换为N进制。那就用整数除N取余数，直到商为0。然后以从下到上的顺序取高位到低位。比如说下面转换为二进制的。\n\n小数部分：假设从十进制小数部分转换为N进制。那就用乘N取整数部分，直到小数为0（或者达到精度要求）。然后从上到下的顺序，取从左到右的结果。比如说：\n\n\n\n\n转换完了之后整数部分和小数部分合并。\n\n二进制/八进制/十六进制之间的转换\n二进制转八进制：小数点起三位一组，整数部分不够三位向前添0，小数部分不够三位向后添0。\n二进制转十六进制：从小数点起四位一组，整数部分不够四位的向前添0，小数部分不够的向后添0\n八进制/十六进制转二进制：上面的逆过程。\n八进制/十六进制转十六进制/八进制：先转换成二进制，然后再从二进制转换过去。\n\n\n\n二进制编码\n自然码：形式和二进制数相同。每位都固定权值。是有权码。\n循环码：相邻的两个数码中，只能有一位数码不同。没有固定权值。是无权码。\n格雷码：是运用比较频繁的一种循环码。如下：\n\n从二进制数到格雷码的转换：对于第i位，看二进制数第i位和第i+1位是否相同。如果相同，那么格雷码第i位是0，否则第i位是1。（溢出的二进制数部分默认是0）\nBCD码：是二十进制码。即二进制形式的十进制码。所以每四位最多表示到9。可以在尾部加上奇偶校验码。例：十进制数转换为8421BCD码。即29020010 1001 0000 0010,每位数码分别转换。\n余三码：属于BCD码。在8421码的基础上每个代码都加上0011得到。余三码也是无权码。\n\n\n\n1.3 逻辑函数\n异或门只有两个输入端\n(这里的高有效和低有效指的是三态门使能端是高有效还是低有效）\n同或就是”异或非“。逻辑图也是这么表示的。\n分配律：\n吸收律：\n冗余律：\n摩根定律\n代入规则\n反演规则：或换成与，与换成或。原变量换成非变量，非变量换成原变量。1换成0，0换成1。用于快速求F的非函数。\n变换后保持原有的运算优先级，即先括号，再与，后或\n不属于单个变量上的反号要保留 \n\n\n对偶规则：与换成或，或换成与，1换成0，0换成1。逻辑变量不作变换。若某个逻辑恒等式成立，则其对偶式也成立。\n\n1.4 卡诺图\n逻辑函数写作唯一的最小项表达式,如：\n\n三变量卡诺图：\n\n四变量卡诺图：11写在10前面，这么写方便最小项合并。\n\n把卡诺图中逻辑相邻的最小项全都合并，就可以得到化简后的式子。化简结果不唯一。注意合并的数量只能是2的倍数。同一个最小项可以被包含多次。\n\n无关项：无关项分为任意项和约束项，用表示。\n\n任意项：对某些输入项，输出是任意的。即这些输入没有对应的具体输出。\n约束项：逻辑变量之间存在约束关系，导致一些特殊取值不可能出现。无关项可以看作1也可以看作0。可以通过这一点来合并更多的最小项，获得化简程度更高的式子。第二章 组合逻辑\n\n\n\n2.1 组合逻辑分析阅读电路图逻辑表达式（与或非）真值表指出逻辑功能。\n有使能端的时候要写出控制信号与F的真值表。\n2.2 组合逻辑设计分析因果关系逻辑规定列真值表卡诺图逻辑函数表达式逻辑图\n例1：  \n例2：  \n  \n  \n  是或，=1是异或。\n2.4 组合逻辑中的竞争冒险电路表达式里，有俩互补输入信号（同时向相反状态变化）时，然后输出端可能有尖峰脉冲，就称为竞争冒险。\n\n尖峰脉冲就是输出那条线突然刺楞了一下，冒出了一个小尖尖。\n\n打个比方。\n现在有，按理来说这玩意儿一直是1.但是你这个得加一个非🚪，所以它的变化就比的慢,那现在从1到0，就要从0到1，但是它又慢了点，是0的时候它还没变。所以会出现和同时是0的情况。\n这个时候是0。\n波形图里头，本来是一条横线，这一下往下刺楞了一下，然后又变回来。那毛刺就叫尖峰脉冲\n\n这产生尖峰脉冲的原因叫延迟（慢了点）。\n还可能有个原因叫畸变，即波形失真：\n\n明显没有延迟，但也有尖峰脉冲。\n延迟和畸变都有，也有尖峰脉冲。\n以上这一大堆估计都不考，要考的是下面的。\n\n判断是否有尖峰脉冲\n\n代数法：\n\n  \n\n卡诺图法：\n\n\n\n\n消除竞争冒险措施\n\n1.引入选通脉冲。原理是输出稳定后才有选通脉冲，才可以输出，否则不产生选通脉冲，不允许输出。\n2.接滤波电容。滤波电容两端电压不能突变，消除干扰脉冲。\n3.修改逻辑设计，增加冗余项。就是卡诺图法的那个意思，找个圈把能包但没包的包起来。\n2.5 常用规模组合逻辑电路标准构件数据选择器（MUX）多路输入，单路输出\n\n控制哪一个输出。\n\n带使能端的MUX\n\n74lS153：双四选一 74LS151：八选一这里给的图是151.注意：，即的时候是高阻，，即的时候正常工作。153的使能端工作方式和151的一致。\n容量扩展：四选一八选一。八选一十六选一。\n实现方法：控制端的最高位控制使能端，低位正常输入，由此确定是高位片输出还是低位片输出。如两个八选一构成十六选一：\n数据分配器（DMUX）单路输入，多路输出\n也称为1：4线数据分配器。\n\n双1：4线数据分配器 74LS155\n\n两个使能端都有效的时候，控制端输入控制的输出位置，如，数据传输到，数据传输到\n\n使能端无效，对应的数据输入被封锁。\n\n1D=2D，1ST=(2ST)’=A2的时候，变为1:8分配器。\n\n\n容量扩展：和选择器的思想基本一致，具体可以参考74LS155变为1:8分配器的例子。\n分时传输：DMUX和MUX一起实现8路数据（分时）传输。\n译码器将输入的二进制码对应到某一位的输出。分为两种，变量译码器和显示译码器。\n\n变量译码器：2—4线译码器，3—8线译码器，4—16线译码器等。n种输入可以得到个输出，每个输出端都对应一个最小项。让使能端E=D可以达到数据分配器的效果。\n\n74LS138 3—8译码器 \n\n输出端是低电平有效，比较特殊。并不是说译码器的输出都是低电平有效。比如说ppt的2—4译码器输出仍旧是高电平有效。\n使能端有两个部分组成，,其中由和组成。正常工作时，的时候有效。具体如图：\n\n双2:4译码器 74LS139\n\n输出是低电平有效，和138一致。\n使能端依旧是的时候可以正常工作。即低电平有效。\n\n译码器扩展：思路还是跟选择器一样。注意图里给的不是139.\n用139和138构建5:32译码器：本质上还是用使能端进行选择。\n\n显示译码器：实现十进制的表达的译码器。\n\n二-十进制码（BCD码）显示译码器显示器件（LED灯管之类的）\n显示译码器 74LS48（共阴极）\n用4选1数据选择器构建16选1数据选择器  使用译码器作为使能端的选择部分：  这里的用的是138，用139也行，原理一样。  如图：  \n逻辑实现：\n\n是熄灭信号，的时候都为0。优先级很低，要其他的全部满足特定条件（）才有效。\n是试灯信号，的时候，七段亮。优先级仅次于\n\n真值表：\n编码器对输入的某一位的输出转换成对应的二进制编码。\n\n\n只能有一个输入端有效，否则输出无效。\n8-3优先编码器 74LS148\n\n允许多个输入信号同时有效。\n只对优先级最高的输入信号进行编码。\nI7优先级最高，I0最低。\n简易真值表如下（ST=1，编码器工作）\n148的使能端有两个,，单独使用是以为准。而扩容的时候两个都要用上。（参考教材p54，高位接低位）\n输出端表达式和普通编码器的区别：\n注意： 输入的是，输入也是反相的，只有对应输入的才视为是有效输入。 输出的是，输出是反相的。\n\nBCD(二-十进制）优先编码器 74LS147\n一片148和与非门实现8421BCD优先编码如图：\n数据比较器完成两个二进制数码大小比较。\n真值表及相应含义：\n记一下大于等于小于对应的逻辑表达式。\n含有输入进位的\n原则：1.本位值大（小）。输出大于（小于）2.本位相等，按输入的进位结果输出。\n四位比较器 74LS85对应的真值表：\n如果一共就只有四位数的比较，那么,接地，接高电平，认为有效。\n从4位扩展为更高位的时候，低位输出接高位的级联输入。\n加法器实现二进制数加法运算。\n按是否考虑低位信号，分为半加器（不考虑）和全加器（考虑）。\n按进位信号的产生方法，分为串行加法器和并行加法器。\n\n一位加法半加器S是和数，C是进位信号\n\n一位加法全加器\n\n串行加法器三个输入(加数,被加数,低位进位信号)两个输出(和数,高位进位信号)\n特点在于每次只能算一位，要算更高位数只能向上递推。\n\n并行加法器特点是可以一次性算完所有位数。\n但会导致位数越高，其逻辑表达式越复杂。\n\n即逻辑表达式里直接用对应低位的进位表达式替换掉低位的进位，直到替换到只有输入的位。\n\n\n四位二进制超前进位全加器 74LS283\n可以实现四位二进制数的全加操作。\n如图：\n\n输出的是加数和被加数相加之后得到的和的低四位。\n级联的操作和一位全加器串行级联是一样的。\n283实现数码转换\n这里给的转换是BCD码和余3码之间的转换。其中余3转BCD码是加1101（13），BCD转余3码是加0011（3）\n如果是从二进制自然码转换：1.BCD码：判9/有进位  +6 （有无进位看进位端。判9用组合逻辑的方法）2.余3码：+3\n奇偶校验器校验传送过程中是否误传。\n对传送得到的信息码产生对应的监督码。分为奇校验和偶校验。\n8位奇偶发生器 74LS280奇校验。\n\n监督码Fod满足：则如果八位信息码里的1为奇数，那么Fod=0，如果是偶数Fod=1.\n接收码Fev满足（Fev表达式和Fod一致）：接受的传输码中的1为奇数，Fev=0，传送正确。接受的传输码中的1为偶数，Fev=1，传输错误。\n\n第三章 时序逻辑时序电路：组合电路和存储电路\n同步时序：电路中的记忆元件统一受公共CP控制。\n异步时序：没有公共的CP信号，各个记忆元件不受同一个CP控制。\n3.1 锁存器按照逻辑功能：SR，D锁存器。\n按照电路结构：基本锁存器，门控锁存器（有使能端）。\n根据输出是否有非门，锁存器也分为低电平有效和高电平有效。做题的时候要看清楚。\nSR锁存器特性方程：\n后面那个式子是约束条件。\n逻辑图和功能表如下：\n注意SR锁存器输入的是。只有满足约束条件，变化才是正常的，如果不满足，即，会导致不稳，状态不定。\nSR锁存器是低电平敏感，由于输入的是，所以相当于是变为高电平时发生变化。\n门控SR锁存器：增加了一个使能端EN。只有在EN=1的时候，才会接受SR的变化信号。否则状态保持不变。\n门控D锁存器 74LS373SR门控锁存器的变体。相当于用替换，替换，得到表达式。所以此时只和的取值有关。\n使能端EN不做变化。\nD=1，EN=1，锁存器置1，D=0且EN=1，锁存器置0.EN=0，状态不变。\n图这么画：\n3.2 触发器按照有无时钟信号：同步触发器和异步触发器\n注意画法C前面的三角代表是按照时钟信号边沿方式工作，三角前的有圆圈代表时钟信号负脉冲（下降沿触发）没有就代表正脉冲（上升沿触发）\nSR触发器激励方程和真值表和SR锁存器一致。唯一的区别是在时钟信号的上升沿触发，即CLK从0到1的时候。（有时候也可能是下降沿触发，看图怎么画）\nD触发器同D锁存器。上升/下降沿触发。\nJK触发器特性方程：\nJK=00 保持JK=01 置0JK=10 置1JK=11 翻转\nT触发器是JK触发器的变体。和SR改D不同，JK改T不需要非门，直接用T替换J和K即可。得到的表达式为：\n功能表：T=0 保持T=1 反转\n\n3.3 寄存器 移位寄存器寄存器：由个D触发器或者锁存器构成，用于储存N位代码的时序逻辑电路\n下图是用D触发器构成的寄存器：\nCP是时钟信号P是输出控制信号iD是输入数据Q是寄存数据iQ是输出数据\n图里采用的是时钟脉冲负边沿触发。数据iD在时钟脉冲的负边沿被送到D触发器。然后输出控制信号来决定是否将Q输出得到iQ。\n输出控制信号低电平有效，高电平阻止。所以真值表：\n移位寄存器分为左移寄存器，右移寄存器，双向移位寄存器\n具有左移，右移和并行置数功能的寄存器叫通用移位寄存器。\n右移寄存器图示：\n如果将其看作是对一个二进制数（从右至左是从低位到高位）的操作，那么右移一位相当于是：其中是该二进制数，是最左边的D触发器输入的值。\n左移寄存器就是反向来接。不放图了。同样的，如果看作二进制数，那么左移一位相当于是\n八位通用移位寄存器74LS299这玩意儿比较复杂。\n功能控制端S1，S0：决定四种工作状态\nS1 S0 = 11：同步并行置数：：三态输出处于高阻态，不能输出。时钟脉冲把输入/输出线的数据装入寄存器。\nS1 S0 = 00：保持模式：：这个模式下不做其他工作。只要输出控制是有效，那就可以读出寄存器。\nS1 S0 = 01：右移模式：：通过时钟脉冲和右移串入实现数据右移。\nS1 S0 = 10：左移模式：：通过时钟脉冲和左移串入实现数据左移。\n输出控制端G1‘，G2’：任何模式，只要输出控制有效，那寄存器就读出。\n清除端：低电平时将寄存器清0。\n输入/输出三态门：输入关闭，输出打开\n时钟端：上升沿实现左移，右移，置数等操作。\n左（串）输入端SR（SL）\n\n并行置数是利用三态门，并行地将数据从三态门装入寄存器中。对应的是数据。输出的时候对应的是\n\n功能表：\n3.4 计数器一般是在移位寄存器的基础上得到的，通过最后的寄存器对最开始的寄存器施加反馈。\n\n对输入脉冲进行计数或者记忆的逻辑器件。\n输入脉冲改变电路状态。状态图是一个有限环\n计数器记忆状态的最大数目被称为模\n\n同步计数器：触发器共用同一个计数脉冲CP，触发器处于同步工作的模式\n异步计数器：不是同一个计数脉冲CP，触发器的状态变化有先后差别。\n\n环形计数器（最后反馈的是)如图：\n对于n个寄存器，可以构成模m=n的环形计数器。没有自启动能力（如000）。\n\n扭环计数器（反馈的是）如图：\n对于n个寄存器，可以构成模m=2n的计数器。无自启动能力（如101）。\n\n二进制同步加法计数器使用JK触发器实现n位二进制同步加法计数器，如图：触发器数目为n，模M=。理解的重点在于翻转的条件。\n\n可以理解为是用所有低位Q全部与之后作为T。构成了T触发器。从而来得到翻转需求。\n\n\n二进制同步减法计数器同样用JK触发器实现，如图：\n\n就是把加法计数器的反过来。\n\n\n二进制可逆计数器本质上就是把加法和减法结合起来，然后给一个加/减控制信号。这样就得到了同步可逆计数器。\n=0作加法计数。=1作减法计数。\n之后再让加减法的驱动方程分别和有效控制信号相与之后再相加，就可以得到可逆计数器驱动方程。比如说3位二进制同步可逆计数器的驱动方程如下：\n\n\n集成4位二进制同步加法计数器74LS161图如下：\n：清零。低电平有效。：置数。低电平有效。：计数：保持\n异步清零：，执行清零。只有在才有其他功能。\n并行置数：,CP达到上升沿时，D0D3置入计数器\n加法计数：,,CP上升沿计数。状态到1111时，产生进位信号1.模M=16.\n保持功能：，，保持状态。\n异步计数器我不知道。\n计数器级联注意级联之后，得到的新的计数器的模是级联计数器模之和。\n\n同步级联：\n\n时钟接到各计数器时钟的输入（计数器同步工作）\n前级计数器的进位CO作为输出接入后级计数器的控制端。只有进位信号有效，后级计数器才可以工作。如图：\n\n\n异步级联：\n\n前级计数器的输出作为后一级计数器的时钟信号如：两片双时钟十进制可逆计数器74LS192构成M=100的可逆计数器：:加计数时钟输入:减计数始终输入:复位端。高电平有效。:进位输出，1001时负脉冲输出:借位输出，0000时负脉冲输出。\n\n\n\n预置法构成任意进制计数器 用模N计数器实现模M的计数器\n\n用预置端让模N从预置状态开始工作，到达，共M个状态。\n到达终止状态时产生预置信号（LD=0），将预置状态重新打入计数器。实现M进制的计数。\n条件：状态有效。\n\n以上是同步预置时的情况，异步预置有所不同。由于异步计数时，最后的终止状态和最初的预置状态是一个状态，所以异步预置的预置状态不能是，而是。这一点和同步预置不一样。\n上面的是构成加法计数器的方法，如果是减法计数器，那预置状态分别是（同步）和（异步）。\n复位法构成任意进制计数器这个要求有复位端（）\n\n计数器从0开始计数。到达M-1状态，产生一个复位信号\n将复位信号加到计数器的复位端，让计数器清零。实现M进制计数。\n\n计数器的应用\n分频器。\n\n:二分频脉冲:四分频脉冲:八分频脉冲:16分频脉冲\n把输入脉冲的频率降低，就说是分频，降低到几分之一就是几分频脉冲。这个用二进制计数器可以完成。\n\n数字序列发生器将不同节拍的脉冲分配到指定的输出。译码器和计数器构成。N位计数器就有个状态。\n脉冲分配器计数器和数据选择器实现序列信号发生器。如：\n\n常用器件总结 74LS153：双四选一数据选择器 74LS151：八选一数据选择器 74LS155：双4:1数据分配器 74LS138：3:8译码器 74LS139：2:4译码器 74LS48：共阴极显示译码器 74LS148：8:3优先编码器 74LS147：BCD二-十进制优先编码器 74LS85：四位比较器 74LS283：四位二进制超前进位全加器 74LS280：8位奇偶发生器 74LS373：门控D锁存器 74LS299：八位通用移位寄存器 74LS161：集成4位二进制同步加法计数器 74LS163：同步4位二进制加法计数器，M=16，cp上升沿触发\n时序电路设计米里型：输出信号取决于电路输入和存储状态穆尔型：输出信号仅取决于电路状态，而与电路输入无关\n","tags":["课程"]},{"title":"离散数学","url":"/2021/10/29/Discrete%20mathematics/","content":" 我啥也不会。 直接跳到牌神的离散笔记 或者poria的离散笔记 我这里除了无意义的重复和有害垃圾般的误导之外一无所有。 拿着你那本离散书烧成灰跺两脚撒一把牛粪都比我这玩意儿有价值。\n离散数学结构 第9章 半群与群9.1 关系及其性质\nbinary relation 二元关系是集合，一个从到的二元关系就是的子集。\n\n所以，从到的二元关系的个数就是子集的个数。\n\n假设有个元素，那么定义在上的二元运算有个。（的子集个数）。\n\n理解为长为（元素总数）的字符串，每一位都可能是1或0，所有可能的字符串有个。\n\n\n\n关系的性质\nreflexive :自反性对应任意的都有（即）\n\n元素集合上有个自反关系。\n\n\n由于所有自反对都在关系里，自反对的存在性固定为1，所有总数除以自反对的总数即可。\n\n\nirreflexive：非自反没自反对。\n\n\nsymmetirc：对称性则有。\n\n\n注意自反算是对称。\n\naymmetric：非对称没对称。\n\nantisymmetric：反对称性和同时成立，则。\n\n\n\n这俩不是对立的:1.同时存在：只有自反对。2.同时不存在：关系里既有非自反的对称，又有不对称的。\n\n\ntransitive：传递性，那么有\n\ncombining relation:关系的合成是到上的关系，是到的关系，有，若有，那么\n\n\n\n注意：对于关系复合运算，是先算再算。这一点极其反直觉。但是：对于函数复合运算,是先算再算。这一点符合直觉。关于这个问题，神说得好： \n\n\n关系的幂：\n\n\n注意：从右到左运算，矩阵表示的时候别弄错了\n\n\n定理：关系是传递的，当且仅当（二者可以互推）\n\n9.2 n元关系及其应用\n定义：如果有都是集合，那么定义在这些集合上的n元关系就是的子集。其中是这个关系的域，是这个关系的degree（阶）\n\nprimary key：主键如果元组的一个域可以用来唯一地确定这个元组，那么就说这个域是这个元组的主键。\n\ncomposite key：复合键可以用来唯一确定一个元组的一组域的笛卡尔积。\n\nextension：关系的外延一个关系当前含有的元组。\n\nintension：数据库内涵数据库更持久的内容，包括其属性和名字。\n\n运算\n\nselection：选择运算运算符为。从所有的元组中找出所有符合条件的元组。\n\nprojection：投影运算懒得写了，放图 \n\n\n 简单说就是从n个域到m个域，只拿规定的m个域，其他的都不要了。\n\njoin：连接运算懒得写 \n\n 简单说就是把两个表拼一起，都有的域只取一遍。\n\n\n9.3 关系的表示\n关系矩阵\n\n\n\n\n\n(布尔积)\n\n性质表示\n\n自反性：矩阵主对角线上所有元素都为1\n对称性：那么（或者同时为0）\n反对称性：,和不可以同时为1\n\n\n\n\n\n\n注意：并不是，而是。（即关系是从，更换了矩阵的行和列）\n\n\ndirecter graphs/digraphs：有向图\n定义：每个元素代表一个点，有序对为有向弧线\nvertices/node：顶点/节点\nedges/arcs：边/弧\ninitial vertex：起点\nterminal vertex：终点\nloop：环\n形如有序对，从顶点到其自身的一个弧表示\n\n\n\n\n性质表示：\n自反性：有向图的每个顶点都有环\n对称性：不同顶点之间的每条边都存在反方向\n传递性：如果同时有从顶点到顶点的弧，顶点到顶点的弧，那么就有顶点到顶点的弧。\n非对称：无双向边无自环\n反自反：只有自环没有双向边\n\n\n\n\n\n9.4 关系的闭包\nclosures of relations：关系的闭包\n\n定义：设是一个在集合上的关系，则关于性质的关系闭包是这样一种关系：它具有性质且包含关系，同时是中所有包含且具有性质的关系的子集。\n\n\n即闭包不仅是包含关系且具有性质的关系，同时也是这种关系中所含有序对最少的关系。\n\n\nreflexive closure：自反闭包在中添加所有不在里形如的有序对即可\n\nsymmetric closure：对称闭包当，则添加\n\ntransitive closure：传递闭包这个是关键，展开讲讲。\n\n\n\n\n如何得到传递闭包一个概念\n\nconnectivity relation：连通性关系常用符号表示，定义如下：自然，的关系矩阵如下：\n\n关系的传递闭包就是连通性关系\n\n这个证明有点意思，这里写一下：1.是传递的且，显而易见。2.证明是所有包含关系且有传递性的关系的子集：先强调一个讲过的定理:如果是传递的，那么。现在假设属于传递关系，由于任意，所以作为所有并集的也是的子集。又因为，所以。证明完毕\n\n\n怎么计算\n\n用定义算：连续计算的布尔幂，直到第次幂为止（即布尔幂开始重复为止）。当计算每次幂时，就求出这个幂与所有较小幂的并。当进行到第次幂时（开始重复时），就得到了的矩阵。例图： \n这种硬算的方法考试会考，所以还是要会\n\n\nwarshall’s algorithm：沃舍尔算法\n\n 理解方法1： 构造时，若第行的第列的元素是1，那么就在保留第行原有所有1的前提下，将第行所有的1按照对应列的方式复制到第行。 理解方法2： 列出第行中的1元素的列， 列出第列中的1元素的行， 标记为1. 例图如下，是初始关系矩阵：  \n\n这个属于是考试重点，必须得会的那种。 其实这里的理解方法是抄的，这个图也是偷的，嘿嘿\n\n\n\n9.5 等价关系\nequivalence relations：等价关系等价关系具有自反性，对称性和传递性。\n\n写法表示对于某个特定的等价关系而言，和是等价的元素。\n\nequivalence classes:等价类\n\n定义：若是一个定义在集合上的关系，那么所有和中元素满足关系的元素的集合被称为的等价类。用表示，若语境下只有一个关系，可以简写称。定义可写作：如果，叫做这个等价类的representative（代表元）。就是说一个等价类里的任何元素都可以作为该等价类的代表元。\n\n\n定理：设是定义在集合上的等价关系，下面的关于集合中的两个元素的命题是等价的：\n\n\n\n\n套关系的三个性质都可以证出来，不赘述了。\n\n\n\n\npartition：划分\n\n定义：集合的不相交的非空子集构成的集合，且这些集合的并集就是。\n\n定理：如果是定义在上的一个等价关系，那么的等价类构成的一个划分。反过来给定一个的一个划分，那么同样也有某个等价关系以此为等价类。\n\n\n 给个例子（从划分到等价类）： \n\n\n9.6 偏序\npartial orderings：偏序定义在集合上的关系，如果是自反，反对称且传递的，就称为偏序，集合和其上的关系一起被称为偏序集，记作，集合中的元素被称为偏序集的元素。\n\n\n等价关系理解成等于，所以左右对称，偏序理解成大于小于，所以不能对称\n\n\n偏序的几个符号：\n\n表示\n表示且反过来是一个道理，不赘述了。\n\n\n可比性如果中元素满足或者，那么可比，否则不可比。（即不存在或者）\n\ntotally ordered/linearly ordered 全序/线序对于偏序集，中的每一对元素都可比，那么这种偏序集就称为全序集/线序集/chian（链）。称为全序/线序。\n\n\n\nwell-ordered：良序对于偏序集，如果是全序，且的每个非空子集都有一个最小元素，那么就称这个偏序集是良序集（well-ordered set)。\n\nthe principle of well-ordered induction：良序归纳定义不好解释，书上翻译也不好，直接放英文版。\n\nlexicographic order：字典顺序（要求或者.\n\n\nHasse Diagrams把这个单列出来是因为我刚发现我把这玩意儿忘干净了。赶紧瞅瞅。\n\ncovering relation：覆盖关系对于偏序集,若且不存在。则称被覆盖。覆盖的有序对称为的覆盖关系。\n\n构建哈塞图在用有向图表示关系的基础上，去掉所有自环，传递，对称，只留下覆盖关系，箭头向上。如：\n\nmaximal and minimal elements：极大元和极小元极大元不小于这个偏序集中的所有元素，极小元不大于这个偏序集中的所有元素。\ngreatest element：最大元。大于偏序集中所有其他元素。唯一存在。\nleast element：最小元，小于偏序集中的所有其他元素。唯一存在。\nupper bound：上界。若是偏序集的子集，若对于所有都有，则称是子集的一个上界。\nlower bound：下界。若是偏序集的子集，若对于所有都有，则称是子集的一个下界。\n**LUB(least upper bound)**：最小上界**GLB(greatest lower bound)**：最大下界顾名思义。不赘述了。\n\n\n\n\nlattice：格若在一个偏序集中，对于任意两个元素，都可以找到它们的最小上界和最大下界，则称这个偏序集为一个格。给个例子：其中是格，不是格（中{}就有两个最小上界）\n\ntopological sorting：拓扑排序\n\n定义：从一个偏序构造一个相容的全序。\ncompatible:相容的只要就有，那么称偏序和全序是相容的。\n这里的和分别泛指某种偏序关系和某种全序关系。\n\n\n拓扑排序的步骤：简单来说就是一直选极小元素拿出来，直到只剩下一个元素，然后把这些元素按照拿出来的顺序用连接起来。如果有多个极小元素怎么办？那就随便挑一个拿出来。给个例子：\n\n\n\n离散数学结构 第九章9.1 再论二元运算\nA binary operation on a set . 集合A上的二元运算。定义为一个处处有定义的函数：可以用来表示。\n性质：所形成的每个有序对都对应一个中的元素，且仅对应一个元素。由于都属于，所以可以说是closed（封闭）的但中的每个元素可以被多个有序对对应，且不是每个元素都会被对应。（即不满足单射满射）  \n关于上的binary opration有多少种，合适的理解是构造的表格，表格中的每个格子都有种填法。所以共有中运算。\n\n\n\n\n注意：和binary relation（二元关系）进行区别， 一个例子就是定义在上的binary relation有个，而定义在上的binary operation有个。（为中的元素个数）\n\n\n二元运算的性质\ncommutative . 可交换的。\n满足交换性，则其表关于主对角线对称。\n\n\nassoative . 可结合的。\n idempotent . 幂等的。\n\n\n\n9.2 半群\nsemigroup . 半群。 非空集合和定义在上的可结合的二元运算。\n\n 有时可以用或者表示半群。\n\n若不可结合则成为groupoid（广义群）。即其仅是封闭的但不可结合。\n\n\nfree semigroup   generated by  . （由产生的）的自由半群。设为非空集合，是中所有元素的所有有限序列的集合。则自由半群是定义在 上，运算为的半群。\n\n理解成是数组，然后是所有中元素组成的有限字符串的集合。运算就是连接字符串的函数（比如strcat）\n\n\nmonoid  幺半群。具有identity（单位元）的半群。\n\nidentity 单位元 满足。\n即幺半群封闭，可结合且具有单位元。\n\n\n\n\nsubsemigroup  子半群。 令为一个半群，为的一个子集，若在运算*下是封闭的，则称 是的子半群。\n\n证明子半群，一般是证明其封闭性，而在其上的可结合一般是默认的。但不排除有些神经病题目里，都不是的子集的情况。\n\n\nsubmonoid  子幺半群。沿袭上面的定义，如果是一个幺半群，且单位元为，那么如果,则称是的子幺半群。\n\n即和的单位元是同一个。是其自身的一个子幺半群\n\n\npowers of  . 幂假设是一个半群，，对于任意，我们依据递归的方式，定义幂如下\n\n，且当是幺半群时，有。\n\n根据这个定义，我们可以认为：\n\n如果都是非负整数，那么\n\n同时也可以得到以下两个定理。\n\n\n如果是一个半群，，，那么 是 的一个子半群。\n如果是一个幺半群，， 或 ，那么 是 的一个子幺半群。\n\n\n注意：这两个定义就为我们指明了怎么去找一个半群的子半群或者子幺半群。\n\n找子半群：1.将半群的任意一个元素添加进集合中，然后添加该元素的幂次2.重复步骤1，添加新加入元素的幂次，直至没有新的元素被添加进来，则得到了一个子半群。找子幺半群：1.将单位元添加进集合2.将半群的任意一个元素添加进集合中，然后添加该元素的幂次3.重复步骤2，添加新加入元素的幂次，直至没有新的元素被添加进来，则得到了一个子幺半群。\n\n同构与同态\nisomorphism .同构。有半群，，如果函数是个双射函数，同时,那么我们说，是isomorphic，是isomorphism，符号表示为。\n\n\n\n显而易见也是同构（isomorphism），不赘述了。\n\n证明函数是同构：\n\n先证明这个函数是单射的，即当时,则。\n再证明这个函数是满射的，即映射域中每个都有对应的。\n证明。\n\n\n证明一个函数是同构按照上述步骤即可。但若要证明两个半群是同构的，则要求在半群之间构造一个同构。 显然，这个看点子，没想到那就是真的想不到了。\n\n 关于简判两个半群是否同构：\n\n同构指的是两个半群的结构是一致的，那么可以选择将两个半群的运算表画出来。 如果用对应元素替代后，得到的表完全一致，则认为这两个半群同构。\n\n根据上面这一大堆，显然，其中是的单位元，是的单位元。所以与幺半群同构的只能是幺半群。\n\nhomomorphism 同态。当的函数满足，则是同态。\n\n\n是逊版的同构，若和同态的，那么中多个元素可以对应同一个中元素，中的某个元素也可以不与任何中元素对应。\n\n\nhomomorphic image . 同态像。满足满射的同态。\n\n\n如果的是一个同态像，那么有（同样的，是的单位元，是的单位元。）之所以要求同态像，是因为只有满射时，才可以保证 对于中任意元素都成立。若中有某一元素不属于这个映射，自然该元素可以和不满足上式，那么也就不是中单位元了。\n\n\n沿袭定义，是同态像，若是的子半群，那么是的子半群。\n\n 沿袭定义，是同态像，若是交换半群，那么是交换半群。\n\n\n\n以上两条均要求是同态像（即满射）,均是为了保证映射包含了中所有元素，才能对中所有元素成立，从而对成立。\n\n9.3 半群的积和商本节介绍了两种由已有半群得到新半群的方法。\n 方法一：做积若和是两个半群，那么是一个半群。其中理解为\n\n自然，若是幺半群，是幺半群，也是幺半群，单位元是\n\n 方法二：做商\n在考虑方法二之前，先说点必要知识。\n\ncongruence relation  同余关系。半群上的一个等价关系（自反，对称，传递）如果满足 和  推出\n\n\n证明同余关系的步骤：\n\n先证明它是一个等价关系；\n再证明可以由和推出。\n\n\n现在我们把第九章的知识引进来，再堆上几个定义。这玩意儿怎么这么多定义，捏妈妈的\n\n第九章提到的等价关系可以定义集合的一个划分，而这里的等价关系可以定义半群的一个划分。我们用或者表示包含的等价类，表示所有等价类的集合。\n\n\nquotient semigroup/factor semigroup . 商半群/因子半群现在我们在上定义一个运算,则其是的一个函数。而理解为 。那么我们称半群就是quotient semigroup/factor semigroup。\n\n\n推论：半群是幺半群，那么其商半群也是幺半群，且其单位元为。\n\n\nnatural homomophism . 自然同态。\n\n半群半群的一个函数，那么显然是一个同态像，这时也可以称为称为自然同态。\n\nfundamental homomorphism theorem . 同态基本定理设是一个半群到半群的一个同态像。又令存在等价关系，其对于中的和满足当且仅当。那么我们可以得到：\n是一个同余关系。\n半群和商半群是同构的。\n\n\n\n\n很长一串，让人没有阅读兴趣。可以这么理解：首先是同余关系显而易见，然后可以认为同余关系把原本中存在的多对一的多个元素，合并成了一个元素，从非单射变成了单射，因此就从原本的同态像变成了同构。即重点在于商代数和同余关系是可以互相转化。知道这个就差不多了。\n\n图解：\n其中和是同态像，是同构。\n9.4 群\nGroup . 群。是其中每个元素都有inverse的幺半群。\n的逆元（inverse）满足\n\n\n\n\n即群满足以下几点：1.满足结合律。2.有单位元。3.封闭。4.每个元素都有且仅有一个逆元，对应的逆元在G中。\n\n\nAbelian group . 阿贝尔群满足交换律的群。\n\ncancellation property . 消去性质先设是一个群，然后都是中的元素。\n\n= 得到(left cancellation property 左消去性质)\n= 得到(right cancellation property 右消去性质)\n\n\n不知道是个啥但反正是个定理\n\n\n\n\n\n唯一解\n\n方程在中有唯一解\n方程在中有唯一解\n\n\n\n\n关于证明（仅第一个式子的证明，第二个式子同理即可）：证明有解：必定为其一个解。证明唯一：若有两个,都是解，则，左消去律完了之后，两个解就相等了。\n\n\nmultiplication table . 乘法表\n\n\n需要提的一点是，在群的乘法表中，每行每列，所有元素都会出现且每个元素仅会出现一次。这一点和唯一解的性质是吻合的。\n\n\nfinite group . 有限群字面意思，有限群的order（阶）是其中元素的个数，表示。\n\n讨论一下阶分别是1，2，3，4的有限群。\n\n一阶群没什么好说的，就一个单位元\n\n二阶群只有一种形式，也没什么好说的。\n\n三阶群同样只有一种形式，即右图这种\n\n\n\n以上的三个群都是阿贝尔群\n\n\n四阶群\n\n \n 这里一共给了四种不同的四阶群，且都是阿贝尔群。 但需要注意的是表，，给的三个群实际上是同构的。\n\n证明：将中的在运算栏里的行和列位置对换，中的在运算栏里的行和列对换，就可以得到和一致的图了。（最多再改下字母）显然不和其余三个同构，因为其任意元素和自身运算都得到单位元，其余三个显然没有这个性质。\n\n 由给出的群称为克莱因四元群，记为,并且其是最小的非循环群，剩余三个称为。\n\n循环群：三角对称群\n\n\n\n   首先给个图\n   \n   接下来我们考虑转置运算   首先，我们定义分别为将图形逆时针旋转\n   \n   \n   \n   然后是关于进行反射的运算。   \n\n解释一下每个图里转置运算的含义以为例：第一列：，即将为1的点移动到目前为2的点的位置第二列：，即将为2的点移动到目前为3的点的位置第三列：，即将为3的点移动到目前为1的点的位置所以表现出来的效果是逆时针旋转\n\n我们将所有这些运算都算进一个集合，然后引进一个运算*（依次序运算）：\n\n注意：这个运算是依次序运算，和复合运算的运算顺序不同。我们称这个群为，单位元是。\n\n然后我们就可以发现一个非常奇怪的地方，如果按照是逆时针旋转，是逆时针旋转的方法进行计算，得到的结果和乘法表并不一致。以和为例，如果依照旋转，那么应该分别得到下图中第一行和第二行的内容：可以看到，这两种运算得到了相同的答案，但这和乘法表的内容是明显相悖的。所以这里要指出一个可能犯的理解上的误区，这里的转置运算并不是旋转，而是点与点的交换。换句话说，在第二行的地方，我们依旧执行，，,而不是旋转三角。这里本来应该有一张正确的过程图，但我懒得画了，理解一下我的意思就行\n犯这种错误理解的主要原因，是中文翻译写的确实剑走偏锋。要是没犯这个错误的话，那恭喜你浪费了阅读这些东西的几十秒。\n\n顺便，这个群是教材提到的第一个不是阿贝尔群的例子\n\n\nsubgroup 子群设是一个子集，使得：\n里有的单位元\n是封闭的\n中有其所有元素对应的逆元是的一个子群。\n\n\n\n\n找子群：1.将单位元添加进集合。2.任意加入一个非单位元的元素，同时加入该元素的幂次和其逆元。3.重复步骤2，把新加入的元素的幂次和逆元加入进集合，直至没有新的元素可以被添加进来，那么我们就得到了一个子群。类似于找子幺半群，但注意要将逆元也添加进来。\n\n\ntrivial subgroups . 平凡子群群的平凡子群就是其本身，和其集合为的子群。//不知道这个定义有啥用。\n\n群的同构与同态\n\n不同阶的群一定不同构。\n同态：设和是两个群。是一个同态，那我们可以得到以下的关系。\n  ()\n如果,则\n就是说的逆对应的逆。\n\n\n如果是的一个子群，则是的一个子群。\n\n\n\n\n证明群的同态和同构，和半群的差不多\n\n9.5 群的积和商\n群的积设和是群，那么的二元运算理解为。\n\n这个定义里没加运算符，脑子里过的时候自己记得加上\n\n\n 。指的是是所有模的余数的集合在加法运算下的群。比如说的集合就是\n\n我们定义如图：\n定理：当且仅当互素时，有\n推广: 如果是群，那么有也是一个群\n\n\n\n\n群上的同余关系（和半群的一致）设是群上的一个同余关系，那么半群是一个群，其中在上的且满足。\n\n\n\n推论：\n\n如果是上的一个同余关系，那么定义为的是半群到半群的一个同态。\n如果是一个同态像，那么当等价关系在上被定义为：当且仅当的时候，我们可以得到：\n是一个同余关系\n由定义的函数是的一个同构。\n\n\n\n\n  说白了这个推论就是把同态和同态基本定理套到了群里头。\n\ncoset . 陪集。陪集分为left coset（左陪集）和right coset（右陪集）。定义如下：设是的一个子群，那么由决定的中的左陪集是集合,同理，右陪集就是集合。\n\nnormal subgroup 正规子群如果对于中所有都有，那么我们说是的一个正规子群。\n\n\n注意: 正规子群并不要求对于中的任意元素都有，而是只要对于任意的，中都有一个元素满足即可。（可为本身）\n\n\n当为中一个元素时如果，那么，当然，同时也有。\n关于这一点的证明：以为例，我们只需要证明和同时成立即可。证明：这个非常明显，因为作为群是封闭的，所以对于任意的，，有，因此。证明：由上面的证明可知，对于任意的，，都有，那么同时也就有（因为是群，所以存在且唯一）。通过这一点，我们不难发现，当确定时，和也就一一对应了（类似于单射）,又因为和的数量是相等的，那么自然每一个都有且只有一个对应（类似于满射和双射被同时证明了）。\n\n\n\n 因此寻找陪集的时候，当时，不用计算或者，因为结果总是。\n\n如果是个阿贝尔群，则其所有子群都是正规子群。\n\n\n这一点显而易见。\n\n\n设是上的一个同余关系，，即是在定义下的包含单位元的等价类，我们容易得知是的一个正规子群。且。//其实我觉得这个定理放在这没啥意义而且显得突兀。但因为教材上显得太突兀了，所以我把这句话写在这里给你看看。\n\n 而从上面的这个定理，我们不难联想到商群实际上就是由的所有左陪集（或右陪集）所组成的，且群中的运算定义为：  并且定义为的是到的一个同态像。所以我们也把写成。\n\n就是也是商群的意思。\n\n\n设是的一个正规子群，是上的下述关系：当且仅当。那么我们可以推断：\n\n是上的同余关系。\n是关于的等价类，其中是的单位元。\n\n\n证明同余关系：1.关于是等价关系的证明省略，自证。2.设,，那么我们需要证明，即。因为是正规子群，所以在中存在元素满足。现在取,再在左右两式左边都与相乘。得到。那么左边为需要证明的部分，右边因为群的封闭性而属于。同余关系得证。\n\n\n证明是：，如果,那么且,即和是等价类。对于中所有元素都满足这一点。所以是。\n\n\n\n\nkernel . 核。设是从群上同态像，则有核且写作，定义为： \n\n就是把所有映射为的元素提出来做了个集合。\n\n 则有\n\n是的一个正规子群。\n商群和同构。\n\n\n易证就是在对应同余关系下的。所以这两点显然成立。\n\n离散数学结构 第十一章 群和编码 鸡掰。这一块没咋看懂。\n11.1 二元信息码和检错码\n\n省略掉又臭又长的引入，11.1开头实际上给了一大堆定义：\n\n设定集合,群设定成在模2加法运算下的集合，即群设定为。模2运算如下图：\n\n是一个运算为的群，其中定义为：注意有个元素，所以其阶为。\n\n\n\n可以理解为中的元素是长为的01字符串的所有可能情况，由于每一位都可能为0或1，所以共有个元素。\n\n\n注意：中的单位元是,每一个元素都是其自身的逆。\n\n\nencoding function 编码函数一般表示成单射函数\ncode word 代码字,则称为的代码字。（是一条01字符串）\n\n\n\n   代码字的传输过程如图：   \n\nweight 权，中1的个数被称为的权，记作。\n\nparity check code 奇偶校验码构建一个编码函数：若（是01字符串，到是0或1），定义，其中：那么称这个编码函数是奇偶校验码。\n\n奇偶校验码的权是偶数，如果传输中有奇数个错误就可以被检测，偶数个检测不了。\n\n\nHamming distance 海明距离表示为（不一定是这个符号，我只是找不到拿这个凑合一下），指的是的权。即和中的个数。\n\nminimum distance 最短距离编码函数的最短距离指的是不同对代码字之间距离的最小值，即\n\n一个编码函数能够检测个或者更少错误当且仅当它的最短距离至少是。\n\n\n\n理解为如果出现的错误个数小于最短距离，那么得到的错误的字符串不可能属于，所以可以发现错误。假如错误的位数超过了最小距离，那么就有可能使，就可能检测不出错误。所以最短距离至少是才能使可检测错误个数小于等于。\n\n\ngroup code 群码如果编码函数满足是的一个子群，那我们称这个编码函数是一个群码。\n\n\n这就要求：1.有中的单位元，即。2.每个元素都有对应的逆元。（如果满足了第一条，那么每个元素都会是其自身逆元）3.是封闭的。\n\n   以及因为是阿贝尔群，所以其所有子群都是正规子群。\n\n设是一个群码，那么的最短距离是非零代码字的最小权。\n\n\n因为对于任意，。即中任意两个元素的海明距离都会是另一个元素的权。\n\n\n关于模2的布尔积的定义：\n\n\n就是布尔积那一套，但区别在于与完后按照1的数目模2。\n\n\n和满足分配律。\n\n设是非负整数且,是一个布尔矩阵，那么函数定义为：是从到的一个同态像。\n\n是的一个正规子群。接下来的讲的是如何定义让其可以用于验错。\n\n\nparity check matrix 奇偶校验矩阵定义如下：这个矩阵共有行，列。用定义一个编码函数，,其中到满足：那么可以得到如下定理：\n\n设，那么当且仅当对某个。\n即当时，传输过程中没有发生差错。\n\n\n\n\n\n   该定理的证明如图：   \n\n由上面的一大堆，稍微绕一下就可以知道：因为同态像的核也可以认为是一个正规子群，所以显然也是一个群码。\n\n11.2 译码和纠错\ndecoding function associated with e . 与e有关的译码函数，然后有满足无噪声时，,其中是上的恒等函数。（）\n\ncorrect k or fewer errors . 矫正个或者更少的错误在的传输有个错误及以下，译码函数可以把转换成原本对应的。就说数据对矫正个或者更少的错误。\n\nmaximum likelihood decoding function . 最大似然方法(最大似然译码函数)\n\n\n简单解释如下：有，从的所有代码字中挑出代码字使得，有，则让。\n\n定理：当是一个的编码函数，是与有关的最大似然译码函数，那么可以纠正个或者更少错误当且仅当的最短距离至少为\n\n\n如果的最短距离小于，那么有可能出现同时与多个的距离相等的情况。\n\n\ncoset leader 陪集首部\n\n设是中的代码字的集合,中有个元素。现传输得到的，其左陪集是其中,那么的权就是和的海明距离。若权最小则最接近，称是陪集首部。\n\n构建最大似然译码函数\n\n\n\n译码表(decoding table)的构建1.先把按顺序列到第一行2.取不在第一行中，且权为1的最小的中的元素，计算和中每个元素的异或值得到左陪集，写到第二行。3.重复步骤二，但要求不在以上所有行中，得到第三行4.如果权为1的写尽，则写权为2的，且依旧要求不在上述行中。直到表中包含了中所有元素比如下图就是一个译码表：\n\n\nsyndrome . 校验子对于一个编码函数，如果我们有奇偶校验矩阵：\n\n\n，就是的校验子。\n\n定理：,属于中的相同左陪集当且仅当\n\n所以可以通过校验子来缩小译码表：\n实际上只是缩小了译码表，但要算的东西多了一堆。\n简单来说就是算一下的校验子，看看和哪个陪集首部一样，比如说和一样，那就通过得到中对应的代码字，这时若有，那么。\n但题目一般就是只给一个奇偶校验矩阵，要你写陪集首部和校验子。这个时候就不得不先算出，然后列出译码表得到陪集首部，之后一个个算出校验子。巨麻烦。\n十一章后面不讲。没了。\n离散数学第八章 高级计数基础8.2 求解线性递推关系感觉不用理解，记解法就完事了，这个应该出不了证明题。\n求解常系数k阶线性齐次递推关系\n一个常系数的阶线性齐次递推关系是形如：的递推关系，其中是实数，且。\n\n特征方程和特征根对于阶线性齐次递推关系，有使得。所以原递推表达式可以写成这个方程称作特征方程，被称为特征根。\n\n\n如果特征方程有不相等的根：\n\n定理1对于递推关系，如果其特征方程有两个不相等的根，那么可以得到，其中是常数。\n\n的求解有初始条件，则由以上两个式子可以解出。\n\n\n如果特征方程有相同的根：\n\n定理2对于递推关系，如果其特征方程只有一个根，那么可以得到，其中是常数。\n\n对于的求解：有初始条件，则由以上两个式子可以解出。\n\n\n一般情况：\n\n定理3：无相同根设都是实数，那么假设特征方程有个不相等的根，那么序列是递推关系的解，当且仅当如果,其中都是常数。\n\n定理4：有相同根设都是实数，那么假设特征方程有个不相等的根，重数分别为那么序列是递推关系的解，当且仅当（（（如果,其中都是常数。\n\n\n求解常系数线性非齐次递推关系不在考纲里，不写。\n8.4 Generating Functions生成函数就是形如这样的函数。\n\n定理1这个定理说明的是生成函数的相加和相乘要怎么算\n定理2这俩说明了广义二项式的形式，以及可以与广义二项式之间相互转换。这个相互转换有点重要，是后面用生成函数求n元素集合k组合数的基础。\n常用的生成函数这几个生成函数用的概率比较大而且不能被其他生成函数推导出来。其中第一个和第三个可以推出大部分的生成函数。\n\n生成函数解决计数问题这种问题一般列出生成函数的形式就可以。一般步骤就是列出每个变量对应的约束条件下的可能性，然后所有这些变量的可能性相乘，最后得到的对应的所需要的结果的系数，就是所有这些变量的组合可能总数。\n\neg1：,给出的生成函数表达式为，全部相乘之后指数为17的系数就是所有组合可能。\neg2：1美元，2美元，5美元买东西，不考虑纸币次序。\n\n","tags":["课程"]},{"title":"无意义","url":"/2021/10/29/test/","content":" 说有一天我跟人王👴在步行街走。\n\n\n 我说人王👴，你说咱读个书为啥啊\n 人王👴：咱读的这个咋叫书。屁用没有。叫狗屎。是旧时代的糟粕，没有实践价值的垃圾。\n 我说不对，咋能叫没有实践价值，那数学学出来不得真能用来买菜。\n 人王👴：我刚说那话重点是”咱“，你细品。\n 我一拍掌说懂了。还真是，书上写的是真东西，咱读进来就成狗屎，本来人间顶级的道理，咱一理解就是糟粕了，就是垃圾了。\n 人王👴：孺子可教。\n 我一转头，我说不对。\n 人王👴：？\n 我说我是狗屎，你是诺贝尔，我是糟粕，你得是菲尔兹，我是垃圾，你少说也得是顶级的人流。\n 人王👴：那叫名流，你是真狗屎。\n 我说对。\n\n 还真是，现在过了一两年了，我还时不时把人王👴说的话拿出来细品。越品越有道理。\n\n 脑子一拍一寻思，趁自己被垃圾分类前多生产一点思想垃圾，也算不虚此行。\n 所以写这破逼玩意儿了。\n 全是垃圾，没点真货色，这属于是个人特色，值得骄傲。\n","tags":["杂谈"]}]